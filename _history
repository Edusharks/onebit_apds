{"entries":[{"timestamp":1735213485295,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":75},{"diffs":[[0,"ver\""],[-1," x=\"0\" y=\"0\""],[0,"></b"]],"start1":107,"start2":107,"length1":20,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"Onebit_APDS.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":222,"start2":222,"length1":71,"length2":44}]},{"type":"added","filename":"Onebit_APDS.ts","value":"/**\n * Custom blocks for One:Bit\n */\n\n\nconst gestureRightID = 4101;\nconst gestureLeftID = 4102;\nconst gestureUpID = 4103;\nconst gestureDownID = 4104;\nconst gestureForwardID = 4105;\nconst gestureBackwardID = 4106;\n\nlet DEBUG = 0;\n/* APDS-9960 I2C address */\nlet APDS9960_I2C_ADDR = 0x39\n\n/* Gesture parameters */\nlet GESTURE_THRESHOLD_OUT = 30\nlet GESTURE_SENSITIVITY_1 = 33\nlet GESTURE_SENSITIVITY_2 = 18\n\n/* Error code for returned values */\nlet ERROR = 0xFF\n\n/* Acceptable device IDs */\nlet APDS9960_ID_1 = 0xA8\nlet APDS9960_ID_2 = 0x9C\n\n/* Misc parameters */\nlet FIFO_PAUSE_TIME = 30      // Wait period (ms) between FIFO reads\n\n/* APDS-9960 register addresses */\nlet APDS9960_ENABLE = 0x80\nlet APDS9960_ATIME = 0x81\nlet APDS9960_WTIME = 0x83\nlet APDS9960_AILTL = 0x84\nlet APDS9960_AILTH = 0x85\nlet APDS9960_AIHTL = 0x86\nlet APDS9960_AIHTH = 0x87\nlet APDS9960_PILT = 0x89\nlet APDS9960_PIHT = 0x8B\nlet APDS9960_PERS = 0x8C\nlet APDS9960_CONFIG1 = 0x8D\nlet APDS9960_PPULSE = 0x8E\nlet APDS9960_CONTROL = 0x8F\nlet APDS9960_CONFIG2 = 0x90\nlet APDS9960_ID = 0x92\nlet APDS9960_STATUS = 0x93\nlet APDS9960_CDATAL = 0x94\nlet APDS9960_CDATAH = 0x95\nlet APDS9960_RDATAL = 0x96\nlet APDS9960_RDATAH = 0x97\nlet APDS9960_GDATAL = 0x98\nlet APDS9960_GDATAH = 0x99\nlet APDS9960_BDATAL = 0x9A\nlet APDS9960_BDATAH = 0x9B\nlet APDS9960_PDATA = 0x9C\nlet APDS9960_POFFSET_UR = 0x9D\nlet APDS9960_POFFSET_DL = 0x9E\nlet APDS9960_CONFIG3 = 0x9F\nlet APDS9960_GPENTH = 0xA0\nlet APDS9960_GEXTH = 0xA1\nlet APDS9960_GCONF1 = 0xA2\nlet APDS9960_GCONF2 = 0xA3\nlet APDS9960_GOFFSET_U = 0xA4\nlet APDS9960_GOFFSET_D = 0xA5\nlet APDS9960_GOFFSET_L = 0xA7\nlet APDS9960_GOFFSET_R = 0xA9\nlet APDS9960_GPULSE = 0xA6\nlet APDS9960_GCONF3 = 0xAA\nlet APDS9960_GCONF4 = 0xAB\nlet APDS9960_GFLVL = 0xAE\nlet APDS9960_GSTATUS = 0xAF\nlet APDS9960_IFORCE = 0xE4\nlet APDS9960_PICLEAR = 0xE5\nlet APDS9960_CICLEAR = 0xE6\nlet APDS9960_AICLEAR = 0xE7\nlet APDS9960_GFIFO_U = 0xFC\nlet APDS9960_GFIFO_D = 0xFD\nlet APDS9960_GFIFO_L = 0xFE\nlet APDS9960_GFIFO_R = 0xFF\n\n/* Bit fields */\nlet APDS9960_PON = 0b00000001\nlet APDS9960_AEN = 0b00000010\nlet APDS9960_PEN = 0b00000100\nlet APDS9960_WEN = 0b00001000\nlet APSD9960_AIEN = 0b00010000\nlet APDS9960_PIEN = 0b00100000\nlet APDS9960_GEN = 0b01000000\nlet APDS9960_GVALID = 0b00000001\n\n/* On/Off definitions */\nlet OFF = 0\nlet ON = 1\n\n/* Acceptable parameters for setMode */\nlet POWER = 0\nlet AMBIENT_LIGHT = 1\nlet PROXIMITY = 2\nlet WAIT = 3\nlet AMBIENT_LIGHT_INT = 4\nlet PROXIMITY_INT = 5\nlet GESTURE = 6\nlet ALL = 7\n\n/* LED Drive values */\nlet LED_DRIVE_100MA = 0\nlet LED_DRIVE_50MA = 1\nlet LED_DRIVE_25MA = 2\nlet LED_DRIVE_12_5MA = 3\n\n/* Proximity Gain (PGAIN) values */\nlet PGAIN_1X = 0\nlet PGAIN_2X = 1\nlet PGAIN_4X = 2\nlet PGAIN_8X = 3\n\n/* ALS Gain (AGAIN) values */\nlet AGAIN_1X = 0\nlet AGAIN_4X = 1\nlet AGAIN_16X = 2\nlet AGAIN_64X = 3\n\n/* Gesture Gain (GGAIN) values */\nlet GGAIN_1X = 0\nlet GGAIN_2X = 1\nlet GGAIN_4X = 2\nlet GGAIN_8X = 3\n\n/* LED Boost values */\nlet LED_BOOST_100 = 0\nlet LED_BOOST_150 = 1\nlet LED_BOOST_200 = 2\nlet LED_BOOST_300 = 3\n\n/* Gesture wait time values */\nlet GWTIME_0MS = 0\nlet GWTIME_2_8MS = 1\nlet GWTIME_5_6MS = 2\nlet GWTIME_8_4MS = 3\nlet GWTIME_14_0MS = 4\nlet GWTIME_22_4MS = 5\nlet GWTIME_30_8MS = 6\nlet GWTIME_39_2MS = 7\n\n/* Default values */\nlet DEFAULT_ATIME = 219     // 103ms\nlet DEFAULT_WTIME = 246     // 27ms\nlet DEFAULT_PROX_PPULSE = 0x87    // 16us, 8 pulses\nlet DEFAULT_GESTURE_PPULSE = 0x89    // 16us, 10 pulses\nlet DEFAULT_POFFSET_UR = 0       // 0 offset\nlet DEFAULT_POFFSET_DL = 0       // 0 offset      \nlet DEFAULT_CONFIG1 = 0x60    // No 12x wait (WTIME) factor\nlet DEFAULT_LDRIVE = LED_DRIVE_100MA\nlet DEFAULT_PGAIN = PGAIN_4X\nlet DEFAULT_AGAIN = AGAIN_4X\nlet DEFAULT_PILT = 0       // Low proximity threshold\nlet DEFAULT_PIHT = 50      // High proximity threshold\nlet DEFAULT_AILT = 0xFFFF  // Force interrupt for calibration\nlet DEFAULT_AIHT = 0\nlet DEFAULT_PERS = 0x11    // 2 consecutive prox or ALS for int.\nlet DEFAULT_CONFIG2 = 0x01    // No saturation interrupts or LED boost  \nlet DEFAULT_CONFIG3 = 0       // Enable all photodiodes, no SAI\nlet DEFAULT_GPENTH = 40      // Threshold for entering gesture mode\nlet DEFAULT_GEXTH = 30      // Threshold for exiting gesture mode    \nlet DEFAULT_GCONF1 = 0x40    // 4 gesture events for int., 1 for exit\nlet DEFAULT_GGAIN = GGAIN_4X\nlet DEFAULT_GLDRIVE = LED_DRIVE_100MA\nlet DEFAULT_GWTIME = GWTIME_2_8MS\nlet DEFAULT_GOFFSET = 0       // No offset scaling for gesture mode\nlet DEFAULT_GPULSE = 0xC9    // 32us, 10 pulses\nlet DEFAULT_GCONF3 = 0       // All photodiodes active during gesture\nlet DEFAULT_GIEN = 0       // Disable gesture interrupts\n\n/* Direction definitions */\nenum DIR {\n    DIR_NONE,\n    DIR_RIGHT,\n    DIR_LEFT,\n    DIR_UP,\n    DIR_DOWN,\n    DIR_NEAR,\n    DIR_FAR,\n    DIR_ALL\n}\n\n/* State definitions */\nenum STATE {\n    NA_STATE,\n    NEAR_STATE,\n    FAR_STATE,\n    ALL_STATE\n}\n\nlet gesture_ud_delta: number;\nlet gesture_lr_delta: number;\nlet gesture_ud_count: number;\nlet gesture_lr_count: number;\nlet gesture_near_count: number;\nlet gesture_far_count: number;\nlet gesture_state: number;\nlet gesture_motion: number;\n\n/**\n * Brickcell Gestures\n */\nenum BrickcellGesture {\n    //% Right\n    Right = 1,\n    //% Left\n    Left = 2,\n    //% Up\n    Up = 3,\n    //% Down\n    Down = 4,\n}\n\n\n\n\n\n\n//% weight=100 color=#993366 icon=\"\\uf2db\" block=\"One:Bit\"\nnamespace One_Bit {\n\n    // Define custom enums for digital pins\n    export enum DigitalPinPrime {\n        //% block=\"P0\"\n        P0 = DigitalPin.P0,\n        //% block=\"P1\"\n        P1 = DigitalPin.P1,\n        //% block=\"P2\"\n        P2 = DigitalPin.P2,\n        //% block=\"P3\"\n        P3 = DigitalPin.P3,\n        //% block=\"P4\"\n        P4 = DigitalPin.P4,\n        //% block=\"P9\"\n        P9 = DigitalPin.P9,\n        //% block=\"P10\"\n        P10 = DigitalPin.P10,\n        //% block=\"P13\"\n        P13 = DigitalPin.P13,\n        //% block=\"P14\"\n        P14 = DigitalPin.P14,\n        //% block=\"P15\"\n        P15 = DigitalPin.P15,\n        //% block=\"P19\"\n        P19 = DigitalPin.P19,\n        //% block=\"P20\"\n        P20 = DigitalPin.P20\n    }\n\n    // Define custom enums for analog pins\n    export enum AnalogPinPrime {\n        //% block=\"P0\"\n        P0 = AnalogPin.P0,\n        //% block=\"P1\"\n        P1 = AnalogPin.P1,\n        //% block=\"P2\"\n        P2 = AnalogPin.P2,\n        //% block=\"P3\"\n        P3 = AnalogPin.P3,\n        //% block=\"P4\"\n        P4 = AnalogPin.P4,\n        //% block=\"P10\"\n        P10 = AnalogPin.P10\n    }\n\n\n    // Enum for PWM pins\n    export enum PWM {\n        //% block=\"P0\"\n        P0 = DigitalPin.P0,\n        //% block=\"P1\"\n        P1 = DigitalPin.P1,\n        //% block=\"P2\"\n        P2 = DigitalPin.P2,\n        //% block=\"P8\"\n        P8 = DigitalPin.P8,\n        //% block=\"P12\"\n        P12 = DigitalPin.P12,\n        //% block=\"P13\"\n        P13 = DigitalPin.P13,\n        //% block=\"P14\"\n        P14 = DigitalPin.P14,\n        //% block=\"P15\"\n        P15 = DigitalPin.P15,\n        //% block=\"P16\"\n        P16 = DigitalPin.P16\n    }\n\n\n    ////////////////////\n    //  PRIME BLOCKS  //\n    ////////////////////\n\n    // Function for reading a digital value from a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% weight=150 blockGap=8\n    //% blockId=\"digital_read\"\n    //% block=\"read digital pin %pin\"\n    export function digitalRead(pin: DigitalPinPrime): number {\n        return pins.digitalReadPin(pin);\n    }\n\n    // Function for writing a digital value to a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% blockId=\"digital_write\"\n    //% weight=140 blockGap= 50\n    //% block=\"write digital pin %pin |to %value\"\n    export function digitalWrite(pin: DigitalPinPrime, value: number): void {\n        pins.digitalWritePin(pin, value);\n    }\n\n    // Function for reading an analog value from a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Analog Pins\"\n    //% blockId=\"analog_read\"\n    //% weight=130 blockGap=8\n    //% block=\"read analog pin %pin\"\n    export function analogRead(pin: AnalogPinPrime): number {\n        return pins.analogReadPin(pin);\n    }\n\n    // Function for writing an analog value to a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Analog Pins\"\n    //% weight=120 blockGap=8\n    //% blockId=\"analog_write\"\n    //% block=\"write analog pin %pin |to %value \"\n    //% value.min=0 value.max=1023\n    export function analogWrite(pin: AnalogPinPrime, value: number): void {\n        pins.analogWritePin(pin, value);\n    }\n\n\n\n    let primeBuffer: Buffer = null; // LED data buffer\n    let primeNumLeds: number = 12;  // Number of LEDs\n    let primeBrightness: number = 255; // Default brightness\n\n\n    /**\n     * Initialize the Prime\n     * @param numLeds number of LEDs in the strip\n     */\n    //% subcategory=\"Prime\"\n    //% blockId=\"one_bit_prime_initialize\"\n    //% group=\"Neo_Color\"\n    //% block=\"initialize Prime with %numLeds|LEDs\"\n    //% weight=150 blockGap=8\n    //% blockNamespace=\"One_Bit\"\n    export function initializePrime(numLeds: number): void {\n        primeNumLeds = numLeds;\n        primeBuffer = control.createBuffer(numLeds * 3);\n        clearPrime(); // Ensure all LEDs start off\n    }\n\n    /**\n     * Show data on the LEDs\n     */\n    function showPrimeBuffer(): void {\n        if (primeBuffer) {\n            light.sendWS2812Buffer(primeBuffer, DigitalPin.P16);\n        }\n    }\n\n    /**\n     * Show rainbow colors on the strip\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_show_rainbow\"\n    //% block=\"show Prime\"\n    //% weight=140 blockGap=8\n    export function showPrime(): void {\n        if (primeBuffer) {\n            for (let i = 0; i < primeNumLeds; i++) {\n                let angle = (i / primeNumLeds) * 2 * Math.PI;\n                let red = Math.max(0, Math.sin(angle + (1 / 3) * Math.PI) * 127 + 128);\n                let green = Math.max(0, Math.sin(angle + (2 / 3) * Math.PI) * 127 + 128);\n                let blue = Math.max(0, Math.sin(angle + (4 / 3) * Math.PI) * 127 + 128);\n                setPrimeLedColorRaw(i, Math.floor(red), Math.floor(green), Math.floor(blue));\n            }\n            showPrimeBuffer();\n        }\n    }\n\n    /**\n     * Clear all LEDs on the strip\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_clear\"\n    //% block=\"clear Prime\"\n    //% weight=130 blockGap=8\n    export function clearPrime(): void {\n        if (primeBuffer) {\n            primeBuffer.fill(0);\n            showPrimeBuffer();\n        }\n    }\n\n\n    /**\n     * Set color of all LEDs on the strip\n     * @param color the color to set\n     */\n    //% subcategory=\"Prime\"\n    //% value.defl='#ff0000'\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_set_color\"\n    //% block=\"set Prime color to %color\"\n    //% weight=120 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setPrimeColor(color: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n        for (let i = 0; i < primeNumLeds; i++) {\n            setPrimeLedColorRaw(i, red, green, blue);\n        }\n        showPrimeBuffer();\n    }\n\n    /**\n * Set color of a specific LED on the strip\n * @param ledIndex the index of the LED to change\n * @param color the color to set\n */\n    //% subcategory=\"Prime\"\n    //% value.defl='#FFFFFF'\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_set_led_color\"\n    //% block=\"set Prime LED %ledIndex|color to %color\"\n    //% weight=110 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setPrimeLedColor(ledIndex: number, color: number): void {\n        if (primeBuffer && ledIndex < primeNumLeds) {\n            let red = (color >> 16) & 0xFF;\n            let green = (color >> 8) & 0xFF;\n            let blue = color & 0xFF;\n\n            let index = ledIndex * 3; // Calculate position in buffer\n            primeBuffer.setUint8(index, (red * primeBrightness) >> 8); // Scale brightness\n            primeBuffer.setUint8(index + 1, (green * primeBrightness) >> 8); // Scale brightness\n            primeBuffer.setUint8(index + 2, (blue * primeBrightness) >> 8); // Scale brightness\n\n            showPrimeBuffer(); // Send updated buffer to the LEDs\n        }\n    }\n\n\n    /**\n     * Set brightness of the strip\n     * @param brightness brightness level (0-255)\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_set_brightness\"\n    //% block=\"set Prime brightness to %brightness\"\n    //% weight=100 blockGap=8\n    export function setPrimeBrightness(brightness: number): void {\n        primeBrightness = Math.clamp(0, 255, brightness);\n        applyBrightness(); // Apply brightness scaling to the buffer\n        showPrimeBuffer(); // Update LEDs with adjusted brightness\n    }\n\n    /**\n     * Apply brightness scaling to the buffer\n     */\n    function applyBrightness(): void {\n        if (!primeBuffer) return;\n\n        for (let i = 0; i < primeNumLeds; i++) {\n            let index = i * 3;\n            primeBuffer[index] = (primeBuffer[index] * primeBrightness) >> 8; // Scale Green\n            primeBuffer[index + 1] = (primeBuffer[index + 1] * primeBrightness) >> 8; // Scale Red\n            primeBuffer[index + 2] = (primeBuffer[index + 2] * primeBrightness) >> 8; // Scale Blue\n        }\n    }\n    /**\n     * Set color of a specific LED using raw RGB values\n     * @param ledIndex the index of the LED to change\n     * @param red Red value (0-255)\n     * @param green Green value (0-255)\n     * @param blue Blue value (0-255)\n     */\n    function setPrimeLedColorRaw(index: number, red: number, green: number, blue: number): void {\n        if (!primeBuffer || index >= primeNumLeds) return;\n\n        let brightnessScale = primeBrightness / 255; // Scale factor for brightness\n        primeBuffer[index * 3 + 0] = Math.floor(green * brightnessScale); // GRB: Green\n        primeBuffer[index * 3 + 1] = Math.floor(red * brightnessScale);   // GRB: Red\n        primeBuffer[index * 3 + 2] = Math.floor(blue * brightnessScale);  // GRB: Blue\n    }\n\n    /**\n     * Show a gradient pattern on the strip\n     * @param startHue the starting hue value (0-360)\n     * @param length the length of the gradient in number of LEDs\n     * @param fromColor starting color of the gradient\n     * @param toColor ending color of the gradient\n     */\n    //% subcategory=\"Prime\"\n    //% value.defl=\"#FFFFFF\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_gradient\"\n    //% block=\"show gradient with start hue %startHue|length %length|from %fromColor|to %toColor\"\n    //% weight=90 blockGap=8\n    //% fromColor.shadow=\"brightColorNumberPicker\" \n    //% toColor.shadow=\"brightColorNumberPicker\"\n    export function showPrimeGradient(startHue: number, length: number, fromColor: number, toColor: number): void {\n        for (let i = 0; i < length; i++) {\n            let blendColor = blend(fromColor, toColor, i / length);\n            setLedColor(i, blendColor); // Custom function to set LED color\n        }\n        updateLeds(); // Custom function to apply changes\n    }\n\n\n    /**\n     * Helper function to blend two colors\n     * @param color1 the first color\n     * @param color2 the second color\n     * @param blend the blend factor between the two colors (0-1)\n     */\n    function blend(color1: number, color2: number, blend: number): number {\n        let r1 = (color1 >> 16) & 0xFF;\n        let g1 = (color1 >> 8) & 0xFF;\n        let b1 = color1 & 0xFF;\n\n        let r2 = (color2 >> 16) & 0xFF;\n        let g2 = (color2 >> 8) & 0xFF;\n        let b2 = color2 & 0xFF;\n\n        let r = Math.round(r1 * (1 - blend) + r2 * blend);\n        let g = Math.round(g1 * (1 - blend) + g2 * blend);\n        let b = Math.round(b1 * (1 - blend) + b2 * blend);\n\n        return (r << 16) | (g << 8) | b;\n    }\n\n\n\n    /**\n     * Custom color picker with all specified colors\n     */\n    //% subcategory=\"Prime\"\n    //% value.defl='#CCFF00'\n    //% group=\"Neo_Color\"\n    //% weight=80 blockGap=20\n    //% blockId=brightColorNumberPicker block=\"%value\"\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.colours='[\"#CCFF00\",\"#CCCC00\",\"#CC9900\",\"#CC6600\",\"#CC3300\",\"#CC0000\",\"#660000\",\"#663300\",\"#666600\",\"#669900\",\"#66CC00\",\"#66FF00\",\"#00FF00\",\"#00CC00\",\"#009900\",\"#006600\",\"#003300\",\"#000000\",\"#CCFF33\",\"#CCCC33\",\"#CC9933\",\"#CC6633\",\"#CC3333\",\"#CC0033\",\"#660033\",\"#663333\",\"#666633\",\"#669933\",\"#66CC33\",\"#66FF33\",\"#00FF33\",\"#00CC33\",\"#009933\",\"#006633\",\"#003333\",\"#000033\",\"#CCFF66\",\"#CCCC66\",\"#CC9966\",\"#CC6666\",\"#CC3366\",\"#CC0066\",\"#660066\",\"#663366\",\"#666666\",\"#669966\",\"#66CC66\",\"#66FF66\",\"#00FF66\",\"#00CC66\",\"#009966\",\"#006666\",\"#003366\",\"#000066\",\"#CCFF99\",\"#CCCC99\",\"#CC9999\",\"#CC6699\",\"#CC3399\",\"#CC0099\",\"#660099\",\"#663399\",\"#666699\",\"#669999\",\"#66CC99\",\"#66FF99\",\"#00FF99\",\"#00CC99\",\"#009999\",\"#006699\",\"#003399\",\"#000099\",\"#CCFFCC\",\"#CCCCCC\",\"#CC99CC\",\"#CC66CC\",\"#CC33CC\",\"#CC00CC\",\"#6600CC\",\"#6633CC\",\"#6666CC\",\"#6699CC\",\"#66CCCC\",\"#66FFCC\",\"#00FFCC\",\"#00CCCC\",\"#0099CC\",\"#0066CC\",\"#0033CC\",\"#0000CC\",\"#CCFFFF\",\"#CCCCFF\",\"#CC99FF\",\"#CC66FF\",\"#CC33FF\",\"#CC00FF\",\"#6600FF\",\"#6633FF\",\"#6666FF\",\"#6699FF\",\"#66CCFF\",\"#66FFFF\",\"#00FFFF\",\"#00CCFF\",\"#0099FF\",\"#0066FF\",\"#0033FF\",\"#0000FF\",\"#FFFFFF\",\"#FFCCFF\",\"#FF99FF\",\"#FF66FF\",\"#FF33FF\",\"#FF00FF\",\"#9900FF\",\"#9933FF\",\"#9966FF\",\"#9999FF\",\"#99CCFF\",\"#99FFFF\",\"#33FFFF\",\"#33CCFF\",\"#3399FF\",\"#3366FF\",\"#3333FF\",\"#3300FF\",\"#FFFFCC\",\"#FFCCCC\",\"#FF99CC\",\"#FF66CC\",\"#FF33CC\",\"#FF00CC\",\"#9900CC\",\"#9933CC\",\"#9966CC\",\"#9999CC\",\"#99CCCC\",\"#99FFCC\",\"#33FFCC\",\"#33CCCC\",\"#3399CC\",\"#3366CC\",\"#3333CC\",\"#3300CC\",\"#FFFF99\",\"#FFCC99\",\"#FF9999\",\"#FF6699\",\"#FF3399\",\"#FF0099\",\"#990099\",\"#993399\",\"#996699\",\"#999999\",\"#99CC99\",\"#99FF99\",\"#33FF99\",\"#33CC99\",\"#339999\",\"#336699\",\"#333399\",\"#330099\",\"#FFFF66\",\"#FFCC66\",\"#FF9966\",\"#FF6666\",\"#FF3366\",\"#FF0066\",\"#990066\",\"#993366\",\"#996666\",\"#999966\",\"#99CC66\",\"#99FF66\",\"#33FF66\",\"#33CC66\",\"#339966\",\"#336666\",\"#333366\",\"#330066\",\"#FFFF33\",\"#FFCC33\",\"#FF9933\",\"#FF6633\",\"#FF3333\",\"#FF0033\",\"#990033\",\"#993333\",\"#996633\",\"#999933\",\"#99CC33\",\"#99FF33\",\"#33FF33\",\"#33CC33\",\"#339933\",\"#336633\",\"#333333\",\"#330033\"]'\n    //% value.fieldOptions.columns=18 value.fieldOptions.className='rgbColorPicker'\n    export function __colorNumberPicker(value: number): number {\n        return value;\n    }\n\n\n    /**\n     * Get a random color\n     */\n    //% blockId=\"one_bit_prime_random_color\"\n    //% value.defl='#ff0000' \n    //% group=\"Neo_Color\" weight=70\n    //% block=\"random color\"\n    //% subcategory=\"Prime\"\n    export function primeRandomColor(): number {\n        return Math.randomRange(0, 0xFFFFFF);\n    }\n\n\n    /**\n     * Convert RGB values to a color number\n     * @param r Red value (0-255)\n     * @param g Green value (0-255)\n     * @param b Blue value (0-255)\n     */\n    //% blockId=\"one_bit_prime_rgb_to_color\"\n    //% value.defl='#ff0000' \n    //% group=\"Neo_Color\" weight=60\n    //% block=\"R %r|G %g|B %b\"\n    //% r.min=0 r.max=255\n    //% g.min=0 g.max=255\n    //% b.min=0 b.max=255\n    //% subcategory=\"Prime\"\n    export function primeRgbToColor(r: number, g: number, b: number): number {\n        return (r << 16) | (g << 8) | b;\n    }\n\n    /**\n     * Convert HSL values to a color number\n     * @param h Hue (0-360)\n     * @param s Saturation (0-100)\n     * @param l Luminosity (0-100)\n     */\n    //% blockId=\"one_bit_prime_hsl_to_color\"\n    //% value.defl='#ff0000' \n    //% group=\"Neo_Color\" weight=50\n    //% block=\"hue %h|saturation %s|luminosity %l\"\n    //% h.min=0 h.max=360\n    //% s.min=0 s.max=100\n    //% l.min=0 l.max=100\n    //% subcategory=\"Prime\"\n    export function primeHslToColor(h: number, s: number, l: number): number {\n        return hslToRgb(h, s, l); // Custom function for HSL to RGB\n    }\n\n    /**\n * Convert HSL values to RGB\n * @param h Hue (0-360)\n * @param s Saturation (0-100)\n * @param l Luminosity (0-100)\n * @returns A packed RGB number (24-bit)\n */\n    function hslToRgb(h: number, s: number, l: number): number {\n        h = h % 360; // Ensure hue wraps around 360\n        s = s / 100; // Convert saturation to a decimal\n        l = l / 100; // Convert luminosity to a decimal\n\n        const c = (1 - Math.abs(2 * l - 1)) * s; // Chroma\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1)); // Second largest component\n        const m = l - c / 2;\n\n        let r = 0, g = 0, b = 0;\n\n        if (h >= 0 && h < 60) {\n            r = c; g = x; b = 0;\n        } else if (h >= 60 && h < 120) {\n            r = x; g = c; b = 0;\n        } else if (h >= 120 && h < 180) {\n            r = 0; g = c; b = x;\n        } else if (h >= 180 && h < 240) {\n            r = 0; g = x; b = c;\n        } else if (h >= 240 && h < 300) {\n            r = x; g = 0; b = c;\n        } else if (h >= 300 && h < 360) {\n            r = c; g = 0; b = x;\n        }\n\n        // Convert RGB components to 8-bit values and pack into a single integer\n        const red = Math.round((r + m) * 255);\n        const green = Math.round((g + m) * 255);\n        const blue = Math.round((b + m) * 255);\n\n        return (red << 16) | (green << 8) | blue;\n    }\n\n\n    /**\n     * Custom function to set a specific LED's color\n     * @param index LED index\n     * @param color RGB color\n     */\n    function setLedColor(index: number, color: number): void {\n        // Send the appropriate signal to the LEDs\n        let r = (color >> 16) & 0xFF;\n        let g = (color >> 8) & 0xFF;\n        let b = color & 0xFF;\n\n        // Logic to send r, g, and b to the specific LED\n        sendSignalToLed(index, r, g, b);\n    }\n\n    /**\n     * Function to send RGB signal to a specific LED\n     */\n    function sendSignalToLed(index: number, r: number, g: number, b: number): void {\n        // Use custom bit-banging logic or timing logic here\n    }\n\n    /**\n     * Function to apply updates to the LEDs\n     */\n    function updateLeds(): void {\n        // Trigger any necessary latch or update commands for the LEDs\n    }\n\n\n\n    ////////////////////\n    // Sensors //\n    ////////////////////\n\n    // Enum for Distance Units\n    export enum Unit {\n        //% block=\"cm\"\n        Centimeters,\n        //% block=\"inches\"\n        Inches\n    }\n\n    /**\n     * Initialize Ultrasonic Sensor and get distance\n     * @param trigPin TRIG pin of the sensor\n     * @param echoPin ECHO pin of the sensor\n     * @param unit Desired distance unit\n     * @param maxCmDistance Maximum measurable distance in centimeters (default is 500)\n     */\n    //% blockId=\"initialize_and_get_ultrasonic_distance\" \n    //% block=\"ultrasonic on trig %trigPin|echo %echoPin|distance in %unit\"\n    //% subcategory=\"Sensors\"\n    //% group=\"Ultrasonic Sensor\"\n    //% trigPin.defl=PWM.P0\n    //% echoPin.defl=PWM.P1\n    //% unit.defl=Unit.Centimeters\n    //% weight=100 blockGap=8\n    export function initializeAndGetUltrasonicDistance(\n        trigPin: PWM,\n        echoPin: PWM,\n        unit: Unit,\n        maxCmDistance = 500\n    ): number {\n        // Send pulse to trigger ultrasonic sensor\n        pins.setPull(trigPin, PinPullMode.PullNone);\n        pins.digitalWritePin(trigPin, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(trigPin, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(trigPin, 0);\n\n        // Read pulse duration from echo pin\n        const d = pins.pulseIn(echoPin, PulseValue.High, maxCmDistance * 58);\n\n        // Handle case where no echo is received\n        if (d === 0) {\n            return -1; // Return -1 for no response\n        }\n\n        // Convert pulse duration to distance\n        switch (unit) {\n            case Unit.Centimeters:\n                return Math.idiv(d, 58); // Convert to cm\n            case Unit.Inches:\n                return Math.idiv(d, 148); // Convert to inches\n            default:\n                return -1;\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n\n\n    export enum tempUnit {\n        //% block=\"Celsius (*C)\"\n        celsius,\n        //% block=\"Fahrenheit (*F)\"\n        fahrenheit,\n    }\n\n    let _temperature: number = -999.0\n    let _humidity: number = -999.0\n\n    /**\n    * Read temperature data from DHT11 sensor.\n    * @param pin the pin number where the DHT11 data pin is connected\n    * @param unit the temperature unit to read (Celsius or Fahrenheit)\n    */\n    //% blockId=\"dht11_temperature\"\n    //% block=\"read Temperature on Pin $pin with Unit $unit\"\n    //% subcategory=\"Sensors\"\n    //% group=\"DHT11\"\n    //% pin.defl=DigitalPin.P0\n    //% unit.defl=celsius\n    export function readTemperature(pin: DigitalPin, unit: tempUnit): number {\n        // Initialize sensor and read data\n        let resultArray: number[] = []\n        let dataArray: boolean[] = []\n        let startTime = input.runningTimeMicros()\n\n        for (let i = 0; i < 40; i++) dataArray.push(false)\n        for (let i = 0; i < 5; i++) resultArray.push(0)\n\n        pins.digitalWritePin(pin, 0)\n        basic.pause(18)\n\n        pins.setPull(pin, PinPullMode.PullUp)\n        pins.digitalReadPin(pin)\n        control.waitMicros(40)\n\n        // Sensor response\n        if (pins.digitalReadPin(pin) == 0) {\n            while (pins.digitalReadPin(pin) == 0);\n            while (pins.digitalReadPin(pin) == 1);\n\n            // Read data\n            for (let i = 0; i < 40; i++) {\n                while (pins.digitalReadPin(pin) == 1);\n                while (pins.digitalReadPin(pin) == 0);\n                control.waitMicros(28)\n                if (pins.digitalReadPin(pin) == 1) dataArray[i] = true\n            }\n\n            // Convert byte data to integer\n            for (let i = 0; i < 5; i++)\n                for (let j = 0; j < 8; j++)\n                    if (dataArray[8 * i + j]) resultArray[i] += 2 ** (7 - j)\n\n            // Temperature and humidity values\n            _humidity = resultArray[0] + resultArray[1] / 100\n            _temperature = resultArray[2] + resultArray[3] / 100\n\n            // Convert to Fahrenheit if needed\n            if (unit == tempUnit.fahrenheit) {\n                _temperature = _temperature * 9 / 5 + 32\n            }\n        }\n\n        return _temperature\n    }\n\n    /**\n    * Read humidity data from DHT11 sensor.\n    * @param pin the pin number where the DHT11 data pin is connected\n    */\n    //% blockId=\"dht11_humidity\"\n    //% block=\"read Humidity on Pin $pin\"\n    //% subcategory=\"Sensors\"\n    //% group=\"DHT11\"\n    //% pin.defl=DigitalPin.P0\n    export function readHumidity(pin: DigitalPin): number {\n        // Initialize sensor and read data\n        let resultArray: number[] = []\n        let dataArray: boolean[] = []\n        let startTime = input.runningTimeMicros()\n\n        for (let i = 0; i < 40; i++) dataArray.push(false)\n        for (let i = 0; i < 5; i++) resultArray.push(0)\n\n        pins.digitalWritePin(pin, 0)\n        basic.pause(18)\n\n        pins.setPull(pin, PinPullMode.PullUp)\n        pins.digitalReadPin(pin)\n        control.waitMicros(40)\n\n        // Sensor response\n        if (pins.digitalReadPin(pin) == 0) {\n            while (pins.digitalReadPin(pin) == 0);\n            while (pins.digitalReadPin(pin) == 1);\n\n            // Read data\n            for (let i = 0; i < 40; i++) {\n                while (pins.digitalReadPin(pin) == 1);\n                while (pins.digitalReadPin(pin) == 0);\n                control.waitMicros(28)\n                if (pins.digitalReadPin(pin) == 1) dataArray[i] = true\n            }\n\n            // Convert byte data to integer\n            for (let i = 0; i < 5; i++)\n                for (let j = 0; j < 8; j++)\n                    if (dataArray[8 * i + j]) resultArray[i] += 2 ** (7 - j)\n\n            // Humidity value\n            _humidity = resultArray[0] + resultArray[1] / 100\n            _temperature = resultArray[2] + resultArray[3] / 100\n        }\n\n        return _humidity\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n\n\n    /**\n     * Get the digital value from the IR sensor (1 for detection, 0 for no detection) on the selected pin.\n     * @param pin the digital pin where the IR sensor is connected\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Sensor\"\n    //% blockId=\"ir_sensor_digital\"\n    //% block=\"ir Sensor on Digital Pin %pin\"\n    //% pin.defl=DigitalPinPrime.P0\n    //% weight=90 blockGap=20\n    export function readIRSensorDigital(pin: DigitalPinPrime): number {\n        // Read the current state of the pin\n        let rawValue = pins.digitalReadPin(pin);\n\n        // Invert the value since 0 means detected and 1 means not detected\n        let invertedValue = rawValue === 0 ? 1 : 0;\n\n        // Reset the pin state (pull back to neutral to avoid latch state)\n        pins.setPull(pin, PinPullMode.PullNone);\n\n        return invertedValue;\n    }\n\n\n\n    /**\n     * Get the analog value from the IR sensor on the selected pin.\n     * @param pin the analog pin where the IR sensor is connected\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Sensor\"\n    //% blockId=\"ir_sensor_analog\"\n    //% block=\"ir Sensor on Analog Pin %pin\"\n    //% pin.defl=AnalogPinPrime.P0\n    //% weight=100 blockGap=20\n    export function readIRSensorAnalog(pin: AnalogPinPrime): number {\n        // Read the value from the specified analog pin\n        const value = pins.analogReadPin(pin);\n        return value; // Return the analog value (0-1023)\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Function to get the digital value of the LDR sensor with reset\n    //% subcategory=\"Sensors\"\n    //% group=\"LDR Sensor\"\n    //% blockId=\"ldr_digital_value_reset\"\n    //% block=\"ldr Sensor on Digital Pin %pin\"\n    //% weight=180 blockGap=20\n    export function getLDRSensorDigitalValueReset(pin: DigitalPinPrime): number {\n        // Ensure the pin is set to input mode before reading\n        pins.setPull(pin, PinPullMode.PullNone);\n\n        // Read the digital value from the pin (either 0 or 1)\n        let value = pins.digitalReadPin(pin);\n\n        // Reset the pin state by reinitializing it as a digital input again\n        pins.setPull(pin, PinPullMode.PullNone); // Reset state by disabling pull-up/down\n\n        // Return the value (0 or 1)\n        return value;\n    }\n\n    // Function to read from an LDR sensor connected to an analog pin\n    //% subcategory=\"Sensors\"\n    //% group=\"LDR Sensor\"\n    //% blockId=\"ldr_analog_value\"\n    //% block=\"ldr Sensor on Analog Pin %pin\"\n    //% weight=180 blockGap=20\n    export function getLDRSensorAnalogValue(pin: AnalogPinPrime): number {\n        // Read and return the inverted analog value (1023 - value)\n        let sensorValue = pins.analogReadPin(pin);\n        return 1023 - sensorValue;  // Invert the value (higher value for dark, lower for light)\n    }\n\n\n\n    /////////////////////////////////////////////////////////////////////////\n\n    // Function to read the moisture sensor value\n    //% subcategory=\"Sensors\"\n    //% group=\"Moisture Sensor\"\n    //% blockId=\"moisture_sensor_value\"\n    //% block=\"moisture sensor value on Pin %pin\"\n    //% weight=180 blockGap=20\n    export function getMoistureSensorValue(pin: AnalogPinPrime): number {\n        // Read and return the analog value from the specified pin\n        return pins.analogReadPin(pin);\n    }\n////////////////////////////////////////////////////////////////////////////\n\n\n\n    const gestureEventId = 3100;\n    let lastGesture = 0;\n\n\n    /* Container for gesture data */\n    export class gesture_data_type {\n        u_data: Buffer;\n        d_data: Buffer;\n        l_data: Buffer;\n        r_data: Buffer;\n        index: number;\n        total_gestures: number;\n        in_threshold: number;\n        out_threshold: number;\n    }\n\n    let gesture_data = new gesture_data_type;\n    let data_buf: Buffer = pins.createBuffer(128);\n\n\n    function APDS9960ReadReg(addr: number): number {\n        let buf: Buffer = pins.createBuffer(1);\n        buf[0] = addr;\n        pins.i2cWriteBuffer(0x39, buf, false);\n        buf = pins.i2cReadBuffer(0x39, 1, false);\n        return buf[0];\n    }\n\n    function APDS9960WriteReg(addr: number, cmd: number) {\n        let buf: Buffer = pins.createBuffer(2);\n\n        buf[0] = addr;\n        buf[1] = cmd;\n\n        pins.i2cWriteBuffer(0x39, buf, false);\n    }\n\n    function readi2c(register: number): number {\n        return pins.i2cReadNumber(register, NumberFormat.UInt8LE);\n    }\n\n    /**\n     * @brief Reads a block (array) of bytes from the I2C device and register\n     *\n     * @param[in] reg the register to read from\n     * @param[out] val pointer to the beginning of the data\n     * @param[in] len number of bytes to read\n     * @return Number of bytes read. -1 on read error.\n     */\n    function APDS9960ReadRegBlock(addr: number, len: number): number {\n        let i: number = 0;\n        let y: number = 0;\n\n        for (let i = 0; i < len; i = i + 4) {\n\n            data_buf[i] = readi2c(0xFc);\n            data_buf[i + 1] = readi2c(0xFd);\n            data_buf[i + 2] = readi2c(0xFe);\n            data_buf[i + 3] = readi2c(0xFf);\n            basic.pause(10);\n            if (DEBUG) {\n                serial.writeLine(data_buf[i].toString() + \" ; \"\n                    + data_buf[i + 1].toString() + \" ; \"\n                    + data_buf[i + 2].toString() + \" ; \"\n                    + data_buf[i + 3].toString() + \" ; \");\n            }\n        }\n\n\n        return len;\n    }\n\n    function getMode(): number {\n        let enable_value: number;\n\n        /* Read current ENABLE register */\n        enable_value = APDS9960ReadReg(APDS9960_ENABLE);\n        return enable_value;\n    }\n\n    function setMode(mode: number, enable: number) {\n        let reg_val: number;\n        /* Read current ENABLE register */\n        reg_val = getMode();\n        /* Change bit(s) in ENABLE register */\n        enable = enable & 0x01;\n        if (mode >= 0 && mode <= 6) {\n            if (enable) {\n                reg_val |= (1 << mode);\n            } else {\n                //reg_val &= ~(1 << mode);\n                reg_val = 0x00;\n            }\n        } else if (mode == ALL) {\n            if (enable) {\n                reg_val = 0x7F;\n            } else {\n                reg_val = 0x00;\n            }\n        }\n\n        /* Write value back to ENABLE register */\n        APDS9960WriteReg(APDS9960_ENABLE, reg_val);\n    }\n\n    /**\n     * @brief Sets the gain of the photodiode during gesture mode\n     *\n     * Value    Gain\n     *   0       1x\n     *   1       2x\n     *   2       4x\n     *   3       8x\n     *\n     * @param[in] gain the value for the photodiode gain\n     * @return True if operation successful. False otherwise.\n     */\n    function setGestureGain(gain: number) {\n        let val: number;\n\n        /* Read value from GCONF2 register */\n        val = APDS9960ReadReg(APDS9960_GCONF2);\n\n        /* Set bits in register to given value */\n        gain &= 0b00000011;\n        gain = gain << 5;\n        val &= 0b10011111;\n        val |= gain;\n\n        /* Write register value back into GCONF2 register */\n        APDS9960WriteReg(APDS9960_GCONF2, val);\n    }\n\n    /**\n     * @brief Sets the LED drive current during gesture mode\n     *\n     * Value    LED Current\n     *   0        100 mA\n     *   1         50 mA\n     *   2         25 mA\n     *   3         12.5 mA\n     *\n     * @param[in] drive the value for the LED drive current\n     * @return True if operation successful. False otherwise.\n     */\n    function setGestureLEDDrive(drive: number) {\n        let val: number;\n\n        /* Read value from GCONF2 register */\n        val = APDS9960ReadReg(APDS9960_GCONF2);\n\n        /* Set bits in register to given value */\n        drive &= 0b00000011;\n        drive = drive << 3;\n        val &= 0b11100111;\n        val |= drive;\n\n        /* Write register value back into GCONF2 register */\n        APDS9960WriteReg(APDS9960_GCONF2, val);\n    }\n\n    /**\n     * @brief Sets the LED current boost value\n     *\n     * Value  Boost Current\n     *   0        100%\n     *   1        150%\n     *   2        200%\n     *   3        300%\n     *\n     * @param[in] drive the value (0-3) for current boost (100-300%)\n     * @return True if operation successful. False otherwise.\n     */\n    function setLEDBoost(boost: number) {\n        let val: number;\n\n        /* Read value from CONFIG2 register */\n        val = APDS9960ReadReg(APDS9960_CONFIG2);\n\n        /* Set bits in register to given value */\n        boost &= 0b00000011;\n        boost = boost << 4;\n        val &= 0b11001111;\n        val |= boost;\n\n        /* Write register value back into CONFIG2 register */\n        APDS9960WriteReg(APDS9960_CONFIG2, val);\n    }\n\n    /**\n     * @brief Sets the time in low power mode between gesture detections\n     *\n     * Value    Wait time\n     *   0          0 ms\n     *   1          2.8 ms\n     *   2          5.6 ms\n     *   3          8.4 ms\n     *   4         14.0 ms\n     *   5         22.4 ms\n     *   6         30.8 ms\n     *   7         39.2 ms\n     *\n     * @param[in] the value for the wait time\n     * @return True if operation successful. False otherwise.\n     */\n    function setGestureWaitTime(time: number) {\n        let val: number;\n\n        /* Read value from GCONF2 register */\n        val = APDS9960ReadReg(APDS9960_GCONF2);\n\n        /* Set bits in register to given value */\n        time &= 0b00000111;\n        val &= 0b11111000;\n        val |= time;\n\n        /* Write register value back into GCONF2 register */\n        APDS9960WriteReg(APDS9960_GCONF2, val);\n    }\n\n    /**\n     * @brief Turns gesture-related interrupts on or off\n     *\n     * @param[in] enable 1 to enable interrupts, 0 to turn them off\n     * @return True if operation successful. False otherwise.\n     */\n    function setGestureIntEnable(enable: number) {\n        let val: number;\n\n        /* Read value from GCONF4 register */\n        val = APDS9960ReadReg(APDS9960_GCONF4);\n\n        /* Set bits in register to given value */\n        enable &= 0b00000001;\n        enable = enable << 1;\n        val &= 0b11111101;\n        val |= enable;\n\n        /* Write register value back into GCONF4 register */\n        APDS9960WriteReg(APDS9960_GCONF4, val);\n    }\n\n    /**\n     * @brief Resets all the parameters in the gesture data member\n     */\n    function resetGestureParameters() {\n        gesture_data.index = 0;\n        gesture_data.total_gestures = 0;\n\n        gesture_ud_delta = 0;\n        gesture_lr_delta = 0;\n\n        gesture_ud_count = 0;\n        gesture_lr_count = 0;\n\n        gesture_near_count = 0;\n        gesture_far_count = 0;\n\n        gesture_state = 0;\n        gesture_motion = DIR.DIR_NONE;\n    }\n\n    /**\n     * @brief Tells the state machine to either enter or exit gesture state machine\n     *\n     * @param[in] mode 1 to enter gesture state machine, 0 to exit.\n     * @return True if operation successful. False otherwise.\n     */\n    function setGestureMode(mode: number) {\n        let val: number;\n\n        /* Read value from GCONF4 register */\n        val = APDS9960ReadReg(APDS9960_GCONF4);\n\n        /* Set bits in register to given value */\n        mode &= 0b00000001;\n        val &= 0b11111110;\n        val |= mode;\n\n        /* Write register value back into GCONF4 register */\n        APDS9960WriteReg(APDS9960_GCONF4, val);\n    }\n\n    /**\n     * Turn the APDS-9960 on\n     *\n     * @return True if operation successful. False otherwise.\n     */\n    function enablePower() {\n        setMode(POWER, 1);\n    }\n\n    /**\n     * @brief Starts the gesture recognition engine on the APDS-9960\n     *\n     * @param[in] interrupts true to enable hardware external interrupt on gesture\n     * @return True if engine enabled correctly. False on error.\n     */\n    function enableGestureSensor(interrupts: boolean) {\n        /* Enable gesture mode\n        Set ENABLE to 0 (power off)\n        Set WTIME to 0xFF\n        Set AUX to LED_BOOST_300\n        Enable PON, WEN, PEN, GEN in ENABLE \n        */\n        resetGestureParameters();\n        APDS9960WriteReg(APDS9960_WTIME, 0xFF);\n        APDS9960WriteReg(APDS9960_PPULSE, DEFAULT_GESTURE_PPULSE);\n        setLEDBoost(LED_BOOST_300);\n        if (interrupts) {\n            setGestureIntEnable(1);\n        } else {\n            setGestureIntEnable(0);\n        }\n        setGestureMode(1);\n        enablePower();\n        setMode(WAIT, 1)\n        setMode(PROXIMITY, 1);\n        setMode(GESTURE, 1);\n    }\n\n    function pads9960_init() {\n        let aa = APDS9960ReadReg(0X92);\n        if (aa == 0xAB) {\n            APDS9960WriteReg(APDS9960_GPENTH, DEFAULT_GPENTH);//0x28\n            APDS9960WriteReg(APDS9960_GEXTH, DEFAULT_GEXTH);//0x1e\n            APDS9960WriteReg(APDS9960_GCONF1, DEFAULT_GCONF1);//0x40\n            setGestureGain(DEFAULT_GGAIN);//0x41\n            setGestureLEDDrive(DEFAULT_GLDRIVE);\n            setGestureWaitTime(DEFAULT_GWTIME);\n            APDS9960WriteReg(APDS9960_GOFFSET_U, DEFAULT_GOFFSET);\n            APDS9960WriteReg(APDS9960_GOFFSET_D, DEFAULT_GOFFSET);\n            APDS9960WriteReg(APDS9960_GOFFSET_L, DEFAULT_GOFFSET);\n            APDS9960WriteReg(APDS9960_GOFFSET_R, DEFAULT_GOFFSET);\n            APDS9960WriteReg(APDS9960_GPULSE, DEFAULT_GPULSE);//0xc9\n            APDS9960WriteReg(APDS9960_GCONF3, DEFAULT_GCONF3);//00\n            setGestureIntEnable(DEFAULT_GIEN);\n        }\n\n        if (0) {\n            /* Gesture config register dump */\n            let reg: number = 0x00;\n            let val: number = 0x00;\n\n            for (reg = 0x80; reg <= 0xAF; reg++) {\n                if ((reg != 0x82) &&\n                    (reg != 0x8A) &&\n                    (reg != 0x91) &&\n                    (reg != 0xA8) &&\n                    (reg != 0xAC) &&\n                    (reg != 0xAD)) {\n                    val = APDS9960ReadReg(reg);\n                    serial.writeLine(reg + \": 0x\" + val);\n                }\n            }\n\n            for (reg = 0xE4; reg <= 0xE7; reg++) {\n                val = APDS9960ReadReg(reg);\n                serial.writeLine(reg + \": 0x\" + val);\n            }\n\n        }\n        // serial.writeLine(\"init sensor finish\");\n    }\n\n    /**\n     * @brief Determines if there is a gesture available for reading\n     *\n     * @return True if gesture available. False otherwise.\n     */\n    function isGestureAvailable(): boolean {\n        let val: number;\n\n        /* Read value from GSTATUS register */\n        val = APDS9960ReadReg(APDS9960_GSTATUS);\n        /* Shift and mask out GVALID bit */\n        val &= APDS9960_GVALID;\n\n        /* Return true/false based on GVALID bit */\n        if (val == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @brief Processes the raw gesture data to determine swipe direction\n     *\n     * @return True if near or far state seen. False otherwise.\n     */\n    function processGestureData(): boolean {\n        let u_first: number = 0;\n        let d_first: number = 0;\n        let l_first: number = 0;\n        let r_first: number = 0;\n        let u_last: number = 0;\n        let d_last: number = 0;\n        let l_last: number = 0;\n        let r_last: number = 0;\n        let ud_ratio_first: number;\n        let lr_ratio_first: number;\n        let ud_ratio_last: number;\n        let lr_ratio_last: number;\n        let ud_delta: number;\n        let lr_delta: number;\n        let i: number;\n\n        /* If we have less than 4 total gestures, that's not enough */\n        if (gesture_data.total_gestures <= 4) {\n            return false;\n        }\n\n        /* Check to make sure our data isn't out of bounds */\n        if ((gesture_data.total_gestures <= 32) && (gesture_data.total_gestures > 0)) {\n\n            /* Find the first value in U/D/L/R above the threshold */\n            for (i = 0; i < gesture_data.total_gestures; i++) {\n                if ((gesture_data.u_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.d_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.l_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.r_data[i] > GESTURE_THRESHOLD_OUT)) {\n\n                    u_first = gesture_data.u_data[i];\n                    d_first = gesture_data.d_data[i];\n                    l_first = gesture_data.l_data[i];\n                    r_first = gesture_data.r_data[i];\n                    break;\n                }\n            }\n\n            /* If one of the _first values is 0, then there is no good data */\n            if ((u_first == 0) || (d_first == 0) || (l_first == 0) || (r_first == 0)) {\n\n                return false;\n            }\n            /* Find the last value in U/D/L/R above the threshold */\n            for (i = gesture_data.total_gestures - 1; i >= 0; i--) {\n\n\n                if ((gesture_data.u_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.d_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.l_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.r_data[i] > GESTURE_THRESHOLD_OUT)) {\n\n                    u_last = gesture_data.u_data[i];\n                    d_last = gesture_data.d_data[i];\n                    l_last = gesture_data.l_data[i];\n                    r_last = gesture_data.r_data[i];\n                    break;\n                }\n            }\n        }\n\n        /* Calculate the first vs. last ratio of up/down and left/right */\n        ud_ratio_first = ((u_first - d_first) * 100) / (u_first + d_first);\n        lr_ratio_first = ((l_first - r_first) * 100) / (l_first + r_first);\n        ud_ratio_last = ((u_last - d_last) * 100) / (u_last + d_last);\n        lr_ratio_last = ((l_last - r_last) * 100) / (l_last + r_last);\n        if (ud_ratio_first == 0 && lr_ratio_first == 0 && ud_ratio_last == 0 && lr_ratio_last == 0) {\n\n            //pads9960_init();\n            // enableGestureSensor(false);\n        }\n        if (DEBUG) {\n            serial.writeLine(\"first Values: \" + \"U:\" + u_first\n                + \" D:\" + d_first\n                + \" L:\" + l_first\n                + \" R:\" + r_first);\n            serial.writeLine(\"Last Values: \" + \"U:\" + u_last\n                + \" D:\" + d_last\n                + \" L:\" + l_last\n                + \" R:\" + r_last);\n            serial.writeLine(\"Ratios: \" + \"UD Fi:\" + ud_ratio_first\n                + \" UD La:\" + ud_ratio_last\n                + \" LR Fi:\" + lr_ratio_first\n                + \" LR La:\" + lr_ratio_last);\n\n        }\n\n        /* Determine the difference between the first and last ratios */\n        ud_delta = ud_ratio_last - ud_ratio_first;\n        lr_delta = lr_ratio_last - lr_ratio_first;\n        if (DEBUG) {\n            serial.writeLine(\"Deltas: \" + \"UD: \" + ud_delta + \" LR: \" + lr_delta);\n        }\n\n        /* Accumulate the UD and LR delta values */\n        gesture_ud_delta += ud_delta;\n        gesture_lr_delta += lr_delta;\n        if (DEBUG) {\n            serial.writeLine(\"Accumulations: \" + \"UD: \" + gesture_ud_delta + \" LR: \" + gesture_lr_delta);\n        }\n        /* Determine U/D gesture */\n        if (gesture_ud_delta >= GESTURE_SENSITIVITY_1) {\n            gesture_ud_count = 1;\n        } else if (gesture_ud_delta <= -GESTURE_SENSITIVITY_1) {\n            gesture_ud_count = -1;\n        } else {\n            gesture_ud_count = 0;\n        }\n\n        /* Determine L/R gesture */\n        if (gesture_lr_delta >= GESTURE_SENSITIVITY_1) {\n            gesture_lr_count = 1;\n        } else if (gesture_lr_delta <= -GESTURE_SENSITIVITY_1) {\n            gesture_lr_count = -1;\n        } else {\n            gesture_lr_count = 0;\n        }\n\n        /* Determine Near/Far gesture */\n        if ((gesture_ud_count == 0) && (gesture_lr_count == 0)) {\n            if ((Math.abs(ud_delta) < GESTURE_SENSITIVITY_2) && (Math.abs(lr_delta) < GESTURE_SENSITIVITY_2)) {\n\n                if ((ud_delta == 0) && (lr_delta == 0)) {\n                    gesture_near_count++;\n                } else if ((ud_delta != 0) || (lr_delta != 0)) {\n                    gesture_far_count++;\n                }\n\n                if ((gesture_near_count >= 10) && (gesture_far_count >= 2)) {\n                    if ((ud_delta == 0) && (lr_delta == 0)) {\n                        gesture_state = STATE.NEAR_STATE;\n                    } else if ((ud_delta != 0) && (lr_delta != 0)) {\n                        gesture_state = STATE.FAR_STATE;\n                    }\n                    return true;\n                }\n            }\n        } else {\n            if ((Math.abs(ud_delta) < GESTURE_SENSITIVITY_2) && (Math.abs(lr_delta) < GESTURE_SENSITIVITY_2)) {\n\n                if ((ud_delta == 0) && (lr_delta == 0)) {\n                    gesture_near_count++;\n                }\n\n                if (gesture_near_count >= 10) {\n                    gesture_ud_count = 0;\n                    gesture_lr_count = 0;\n                    gesture_ud_delta = 0;\n                    gesture_lr_delta = 0;\n                }\n            }\n        }\n\n        if (DEBUG) {\n            serial.writeLine(\"UD_CT: \" + gesture_ud_count + \" LR_CT: \" + gesture_lr_count + \" NEAR_CT: \" + gesture_near_count\n                + \" FAR_CT: \" + gesture_far_count);\n        }\n\n        return true;\n    }\n\n    /**\n     * @brief Determines swipe direction or near/far state\n     *\n     * @return True if near/far event. False otherwise.\n     */\n    function decodeGesture(): boolean {\n        //(\"gesture_state\"+gesture_state);\n        // serial.writeLine(\"gesture_ud_count: \"+gesture_ud_count+\" ; \"+\"gesture_lr_count: \"+gesture_lr_count);\n        /* Return if near or far event is detected */\n        if (gesture_state == STATE.NEAR_STATE) {\n            gesture_motion = DIR.DIR_NEAR;\n            return true;\n        } else if (gesture_state == STATE.FAR_STATE) {\n            gesture_motion = DIR.DIR_FAR;\n            return true;\n        }\n\n        /* Determine swipe direction */\n        if ((gesture_ud_count == -1) && (gesture_lr_count == 0)) {\n            gesture_motion = DIR.DIR_UP;\n        } else if ((gesture_ud_count == 1) && (gesture_lr_count == 0)) {\n            gesture_motion = DIR.DIR_DOWN;\n        } else if ((gesture_ud_count == 0) && (gesture_lr_count == 1)) {\n            gesture_motion = DIR.DIR_RIGHT;\n        } else if ((gesture_ud_count == 0) && (gesture_lr_count == -1)) {\n            gesture_motion = DIR.DIR_LEFT;\n        } else if ((gesture_ud_count == -1) && (gesture_lr_count == 1)) {\n            if (Math.abs(gesture_ud_delta) > Math.abs(gesture_lr_delta)) {\n                gesture_motion = DIR.DIR_UP;\n            } else {\n                gesture_motion = DIR.DIR_RIGHT;\n            }\n        } else if ((gesture_ud_count == 1) && (gesture_lr_count == -1)) {\n            if (Math.abs(gesture_ud_delta) > Math.abs(gesture_lr_delta)) {\n                gesture_motion = DIR.DIR_DOWN;\n            } else {\n                gesture_motion = DIR.DIR_LEFT;\n            }\n        } else if ((gesture_ud_count == -1) && (gesture_lr_count == -1)) {\n            if (Math.abs(gesture_ud_delta) > Math.abs(gesture_lr_delta)) {\n                gesture_motion = DIR.DIR_UP;\n            } else {\n                gesture_motion = DIR.DIR_LEFT;\n            }\n        } else if ((gesture_ud_count == 1) && (gesture_lr_count == 1)) {\n            if (Math.abs(gesture_ud_delta) > Math.abs(gesture_lr_delta)) {\n                gesture_motion = DIR.DIR_DOWN;\n            } else {\n                gesture_motion = DIR.DIR_RIGHT;\n            }\n        } else {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @brief Processes a gesture event and returns best guessed gesture\n     *\n     * @return Number corresponding to gesture. -1 on error.\n     */\n    function readGesture(): number {\n        let fifo_level: number = 0;\n        let bytes_read: number = 0;\n        let fifo_data: number[] = [];\n        let gstatus: number;\n        let motion: number;\n        let i: number;\n        //resetGestureParameters();\n        gesture_data.d_data = pins.createBuffer(32);\n        gesture_data.u_data = pins.createBuffer(32);\n        gesture_data.l_data = pins.createBuffer(32);\n        gesture_data.r_data = pins.createBuffer(32);\n        //(\"read sensor start\");\n        /* Make sure that power and gesture is on and data is valid */\n        if (!isGestureAvailable() || !(getMode() & 0b01000001)) {\n            return DIR.DIR_NONE;\n        }\n\n        /* Keep looping as long as gesture data is valid */\n        while (1) {\n            basic.pause(30);\n            /* Get the contents of the STATUS register. Is data still valid? */\n            gstatus = APDS9960ReadReg(APDS9960_GSTATUS);\n            /* If we have valid data, read in FIFO */\n            if ((gstatus & APDS9960_GVALID) == APDS9960_GVALID) {\n                /* Read the current FIFO level */\n                fifo_level = APDS9960ReadReg(APDS9960_GFLVL);\n\n                if (DEBUG) {\n                    serial.writeLine(\"FIFO Level: \" + fifo_level);\n                }\n\n                /* If there's stuff in the FIFO, read it into our data block */\n                if (fifo_level > 0) {\n                    bytes_read = APDS9960ReadRegBlock(APDS9960_GFIFO_U,\n                        (fifo_level * 4));\n                    // bytes_read = APDS9960ReadRegBlock(APDS9960_GFIFO_U,fifo_level );\n\n                    for (let i = 0; i < bytes_read; i++) {\n                        fifo_data[i] = data_buf[i];\n                    }\n\n                    if (0) {\n                        serial.writeLine(\"FIFO Dump: \");\n                        for (i = 0; i < bytes_read; i++) {\n                            serial.writeLine(\"NO. \" + i + \" : \" + fifo_data[i]);\n                        }\n                        serial.writeLine(\"FIFO END\");\n                    }\n\n                    if (bytes_read >= 4) {\n                        for (let ii = 0; ii < bytes_read; ii = ii + 4) {\n                            gesture_data.u_data[gesture_data.index] = fifo_data[ii + 0];\n                            gesture_data.d_data[gesture_data.index] = fifo_data[ii + 1];\n                            gesture_data.l_data[gesture_data.index] = fifo_data[ii + 2];\n                            gesture_data.r_data[gesture_data.index] = fifo_data[ii + 3];\n                            gesture_data.index++;\n                            gesture_data.total_gestures++;\n                        }\n\n                        if (0) {\n                            serial.writeLine(\"Up Data: \");\n                            for (i = 0; i < gesture_data.total_gestures; i++) {\n                                serial.writeLine(gesture_data.u_data[i].toString());\n                            }\n                            serial.writeLine(\"Up END\");\n                        }\n\n                        /* Filter and process gesture data. Decode near/far state */\n                        if (processGestureData()) {\n                            if (decodeGesture()) {\n                                motion = gesture_motion;\n                                if (DEBUG) {\n                                    serial.writeLine(\"gesture_motion: \" + gesture_motion.toString());\n                                }\n                                resetGestureParameters();\n                                return motion;\n                            }\n                        }\n                        /* Reset data */\n                        gesture_data.index = 0;\n                        gesture_data.total_gestures = 0;\n                    }\n\n                }\n\n            }\n            else {\n                /* Determine best guessed gesture and clean up */\n                basic.pause(30);\n                decodeGesture();\n                motion = gesture_motion;\n                if (DEBUG) {\n                    serial.writeLine(\"END: \");\n                    serial.writeLine(\"gesture_motion\" + gesture_motion);\n                }\n\n                resetGestureParameters();\n                return motion;\n            }\n\n        }\n\n        motion = gesture_motion;\n        return motion;\n    }\n\n    /**\n     * Create a new driver of Grove - Gesture\n     */\n    //% blockId=grove_gesture_init\n    //% block=\"%apds9960|Initiate the Gesture sensor APDS9960\"\n    //% subcategory=\"gesture apds9960\"\n    export function init() {\n        pads9960_init();\n        enableGestureSensor(false);\n        //serial.writeLine(\"Initializing\");\n        if (0) {\n            /* Gesture config register dump */\n            let reg: number = 0x00;\n            let val: number = 0x00;\n\n            for (reg = 0x80; reg <= 0xAF; reg++) {\n                if ((reg != 0x82) &&\n                    (reg != 0x8A) &&\n                    (reg != 0x91) &&\n                    (reg != 0xA8) &&\n                    (reg != 0xAC) &&\n                    (reg != 0xAD)) {\n                    val = APDS9960ReadReg(reg);\n                    //serial.writeLine(reg + \": 0x\" + val);\n                }\n            }\n\n            for (reg = 0xE4; reg <= 0xE7; reg++) {\n                val = APDS9960ReadReg(reg);\n                //serial.writeLine(reg + \": 0x\" + val);\n            }\n\n        }\n    }\n\n    /**\n     * Do something when a gesture is detected by Grove - Gesture\n     * @param gesture type of gesture to detect\n     * @param handler code to run\n     */\n    //% blockId=grove_gesture_create_event\n    //% block=\"Gesture|%gesture\"\n    //% subcategory=\"gesture apds9960\"\n    //export function onGesture(gesture: BrickcellGesture, handler: Action) {\n    export function onGesture(gesture: BrickcellGesture, body: () => void): void {\n        //control.onEvent(gestureEventId, gesture, handler);\n        //let apds9960 = new APDS9960();\n        //init();\n        if (gesture == BrickcellGesture.Right) control.onEvent(gestureRightID, gesture, body);\n        if (gesture == BrickcellGesture.Left) control.onEvent(gestureLeftID, gesture, body);\n        if (gesture == BrickcellGesture.Up) control.onEvent(gestureUpID, gesture, body);\n        if (gesture == BrickcellGesture.Down) control.onEvent(gestureDownID, gesture, body);\n\n        control.inBackground(() => {\n            while (true) {\n                const gesture = readGesture();\n\n                if (gesture != lastGesture) {\n                    lastGesture = gesture;\n                    switch (gesture) {\n                        case 1:\n                            control.raiseEvent(gestureRightID, BrickcellGesture.Right);\n                            break;\n                        case 2:\n                            control.raiseEvent(gestureLeftID, BrickcellGesture.Left);\n                            break;\n                        case 3:\n                            control.raiseEvent(gestureUpID, BrickcellGesture.Up);\n                            break;\n                        case 4:\n                            control.raiseEvent(gestureDownID, BrickcellGesture.Down);\n                            break;\n                    }\n                }\n                //basic.pause(1800);\n                basic.pause(50);\n                //serial.writeLine(\"Start gesture.\");\n            }\n        })\n    }\n\n\n    /////////////////////////////////////////////////////////////////////////\n    ////////////////////\n    //Actuators //\n    ////////////////////\n\n\n    // Convert any DigitalPinPrime to AnalogPin (for PWM control)\n    function getDigitalPin(pin: DigitalPinPrime): DigitalPin {\n        switch (pin) {\n            case DigitalPinPrime.P0: return DigitalPin.P0;\n            case DigitalPinPrime.P1: return DigitalPin.P1;\n            case DigitalPinPrime.P2: return DigitalPin.P2;\n            case DigitalPinPrime.P3: return DigitalPin.P3;\n            case DigitalPinPrime.P4: return DigitalPin.P4;\n            case DigitalPinPrime.P9: return DigitalPin.P9;\n            case DigitalPinPrime.P10: return DigitalPin.P10;\n            case DigitalPinPrime.P13: return DigitalPin.P13;\n            case DigitalPinPrime.P14: return DigitalPin.P14;\n            case DigitalPinPrime.P15: return DigitalPin.P15;\n            case DigitalPinPrime.P19: return DigitalPin.P19;\n            case DigitalPinPrime.P20: return DigitalPin.P20;\n            default: return DigitalPin.P0; // Fallback\n        }\n    }\n\n    // Define servo positions enumeration\n    export enum ServoPosition {\n        //% block=\"0 degrees\"\n        Zero = 0,\n        //% block=\"45 degrees\"\n        FortyFive = 45,\n        //% block=\"90 degrees\"\n        Ninety = 90,\n        //% block=\"135 degrees\"\n        OneThirtyFive = 135,\n        //% block=\"180 degrees\"\n        OneEighty = 180\n    }\n\n\n    /**\n    * Moves a servo to a specified position.\n    * @param pin which pin to control\n    * @param position the position to move to\n    */\n    //% subcategory=\"Actuators\"\n    //% weight=150 blockGap=8\n    //% group=\"Positional Servo\"\n    //% blockId=\"move_positional_servo\"\n    //% block=\"move servo on pin %pin|to position %position\"\n    //% position.min=0 position.max=180\n    export function movePositionalServo(pin: DigitalPinPrime, position: number): void {\n        const angle = Math.clamp(0, 180, position);  // Ensure angle is within 0-180 range\n        pins.servoWritePin(getDigitalPin(pin), angle);\n    }\n\n    /**\n     * Moves a servo to a specified position.\n     * @param pin which pin to control\n     * @param position the position to move to\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=120 blockGap=8\n    //% group=\"Positional Servo\"\n    //% blockId=\"move_positional_servo_to_fixed_point\"\n    //% block=\"move servo on pin %pin|to position %position\"\n    export function movePositionalServofixed(pin: DigitalPinPrime, position: ServoPosition): void {\n        // Using the ServoPosition enum, which already contains the angle values\n        pins.servoWritePin(getDigitalPin(pin), position);  // position is directly the angle in degrees\n    }\n\n    //% subcategory=\"Actuators\"\n    //% weight=10 blockGap=8\n    //% group=\"Positional Servo\" \n    //% blockId=\"move_servo_from_to\"\n    //% block=\"move servo on pin %pin|from angle %from|to angle %to|over %duration seconds\"\n    //% from.min=0 from.max=180\n    //% to.min=0 to.max=180\n    //% duration.min=1 duration.max=10\n    export function moveServoFromTo1(pin: DigitalPinPrime, from: number, to: number, duration: number): void {\n        const startAngle = Math.clamp(0, 180, from);\n        const endAngle = Math.clamp(0, 180, to);\n        const steps = Math.abs(endAngle - startAngle);\n        const stepDuration = duration * 1000 / steps;\n\n        // Loop through each step and move the servo\n        for (let i = 0; i <= steps; i++) {\n            // Calculate the current angle for the servo based on the direction of movement\n            const currentAngle = startAngle + (endAngle > startAngle ? i : -i);\n\n            // Ensure that we don't exceed the target angle, especially when rounding\n            if ((endAngle > startAngle && currentAngle >= endAngle) || (endAngle < startAngle && currentAngle <= endAngle)) {\n                // Set the final angle to the target and break the loop\n                pins.servoWritePin(getDigitalPin(pin), endAngle);\n                break; // exit the loop once we reach the target angle\n            } else {\n                // Otherwise, move the servo to the current calculated angle\n                pins.servoWritePin(getDigitalPin(pin), currentAngle);\n            }\n\n            // Pause for the time before moving to the next step\n            basic.pause(stepDuration);\n        }\n    }\n\n    /**\n     * Controls the speed and direction of a continuous rotation servo.\n     * @param pin which pin to control\n     * @param speed the speed of the servo motor (-100 to 100)\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=40 blockGap=8\n    //% group=\"Continuous Servo\"\n    //% blockId=\"move_continuous_servo\"\n    //% block=\"set continuous servo on pin %pin|to speed %speed\"\n    //% speed.min=-100 speed.max=100\n    export function moveContinuousServo(pin: DigitalPinPrime, speed: number): void {\n        const speedValue = Math.clamp(-100, 100, speed);  // Ensure speed is within -100 to 100 range\n\n        // Map speed to the correct PWM values (using -100 for full reverse and 100 for full forward)\n        const pwmValue = Math.map(speedValue, -100, 100, 0, 180);  // 40-120 range typically works for continuous servos\n\n        // Write the PWM value to the pin\n        pins.servoWritePin(getDigitalPin(pin), pwmValue);\n    }\n\n\n    /**\n     * Stops the continuous rotation servo.\n     * @param pin which pin to control\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=30 blockGap=8\n    //% group=\"Continuous Servo\"\n    //% blockId=\"stop_continuous_servo\"\n    //% block=\"stop continuous servo on pin %pin\"\n    export function stopContinuousServo(pin: DigitalPinPrime): void {\n        // Set speed to 0 to stop the motor\n        pins.servoWritePin(getDigitalPin(pin), 90);  // 90 typically stops a continuous servo\n    }\n\n\n    /////////////////////////////////////////////////////////////////////////\n\n\n    declare interface Math {\n        floor(x: number): number;\n    }\n    let font: Buffer;\n    const SSD1306_SETCONTRAST = 0x81\n    const SSD1306_SETCOLUMNADRESS = 0x21\n    const SSD1306_SETPAGEADRESS = 0x22\n    const SSD1306_DISPLAYALLON_RESUME = 0xA4\n    const SSD1306_DISPLAYALLON = 0xA5\n    const SSD1306_NORMALDISPLAY = 0xA6\n    const SSD1306_INVERTDISPLAY = 0xA7\n    const SSD1306_DISPLAYOFF = 0xAE\n    const SSD1306_DISPLAYON = 0xAF\n    const SSD1306_SETDISPLAYOFFSET = 0xD3\n    const SSD1306_SETCOMPINS = 0xDA\n    const SSD1306_SETVCOMDETECT = 0xDB\n    const SSD1306_SETDISPLAYCLOCKDIV = 0xD5\n    const SSD1306_SETPRECHARGE = 0xD9\n    const SSD1306_SETMULTIPLEX = 0xA8\n    const SSD1306_SETLOWCOLUMN = 0x00\n    const SSD1306_SETHIGHCOLUMN = 0x10\n    const SSD1306_SETSTARTLINE = 0x40\n    const SSD1306_MEMORYMODE = 0x20\n    const SSD1306_COMSCANINC = 0xC0\n    const SSD1306_COMSCANDEC = 0xC8\n    const SSD1306_SEGREMAP = 0xA0\n    const SSD1306_CHARGEPUMP = 0x8D\n    const chipAdress = 0x3C\n    const xOffset = 0\n    const yOffset = 0\n    let charX = 0\n    let charY = 0\n    let displayWidth = 128\n    let displayHeight = 64 / 8\n    let screenSize = 0\n\n    //let font: Array<Array<number>>\n    let loadStarted: boolean;\n    let loadPercent: number;\n    function command(cmd: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = 0x00\n        buf[1] = cmd\n        pins.i2cWriteBuffer(chipAdress, buf, false)\n    }\n\n\n    //% subcategory=\"Actuators\"\n    //% group=\"OLED\"\n    //% block=\"initialize OLED with width $width height $height\"\n    //% width.defl=128\n    //% height.defl=64\n    //% weight=150\n    export function initOLED(width: number, height: number) {\n        command(SSD1306_DISPLAYOFF);\n        command(SSD1306_SETDISPLAYCLOCKDIV);\n        command(0x80);                                  // the suggested ratio 0x80\n        command(SSD1306_SETMULTIPLEX);\n        command(0x3F);\n        command(SSD1306_SETDISPLAYOFFSET);\n        command(0x0);                                   // no offset\n        command(SSD1306_SETSTARTLINE | 0x0);            // line #0\n        command(SSD1306_CHARGEPUMP);\n        command(0x14);\n        command(SSD1306_MEMORYMODE);\n        command(0x00);                                  // 0x0 act like ks0108\n        command(SSD1306_SEGREMAP | 0x1);\n        command(SSD1306_COMSCANDEC);\n        command(SSD1306_SETCOMPINS);\n        command(0x12);\n        command(SSD1306_SETCONTRAST);\n        command(0xCF);\n        command(SSD1306_SETPRECHARGE);\n        command(0xF1);\n        command(SSD1306_SETVCOMDETECT);\n        command(0x40);\n        command(SSD1306_DISPLAYALLON_RESUME);\n        command(SSD1306_NORMALDISPLAY);\n        command(SSD1306_DISPLAYON);\n        displayWidth = width\n        displayHeight = height / 8\n        screenSize = displayWidth * displayHeight\n        charX = xOffset\n        charY = yOffset\n        font = hex`\n    0000000000\n    3E5B4F5B3E\n    3E6B4F6B3E\n    1C3E7C3E1C\n    183C7E3C18\n    1C577D571C\n    1C5E7F5E1C\n    00183C1800\n    FFE7C3E7FF\n    0018241800\n    FFE7DBE7FF\n    30483A060E\n    2629792926\n    407F050507\n    407F05253F\n    5A3CE73C5A\n    7F3E1C1C08\n    081C1C3E7F\n    14227F2214\n    5F5F005F5F\n    06097F017F\n    006689956A\n    6060606060\n    94A2FFA294\n    08047E0408\n    10207E2010\n    08082A1C08\n    081C2A0808\n    1E10101010\n    0C1E0C1E0C\n    30383E3830\n    060E3E0E06\n    0000000000\n    00005F0000\n    0007000700\n    147F147F14\n    242A7F2A12\n    2313086462\n    3649562050\n    0008070300\n    001C224100\n    0041221C00\n    2A1C7F1C2A\n    08083E0808\n    0080703000\n    0808080808\n    0000606000\n    2010080402\n    3E5149453E\n    00427F4000\n    7249494946\n    2141494D33\n    1814127F10\n    2745454539\n    3C4A494931\n    4121110907\n    3649494936\n    464949291E\n    0000140000\n    0040340000\n    0008142241\n    1414141414\n    0041221408\n    0201590906\n    3E415D594E\n    7C1211127C\n    7F49494936\n    3E41414122\n    7F4141413E\n    7F49494941\n    7F09090901\n    3E41415173\n    7F0808087F\n    00417F4100\n    2040413F01\n    7F08142241\n    7F40404040\n    7F021C027F\n    7F0408107F\n    3E4141413E\n    7F09090906\n    3E4151215E\n    7F09192946\n    2649494932\n    03017F0103\n    3F4040403F\n    1F2040201F\n    3F4038403F\n    6314081463\n    0304780403\n    6159494D43\n    007F414141\n    0204081020\n    004141417F\n    0402010204\n    4040404040\n    0003070800\n    2054547840\n    7F28444438\n    3844444428\n    384444287F\n    3854545418\n    00087E0902\n    18A4A49C78\n    7F08040478\n    00447D4000\n    2040403D00\n    7F10284400\n    00417F4000\n    7C04780478\n    7C08040478\n    3844444438\n    FC18242418\n    18242418FC\n    7C08040408\n    4854545424\n    04043F4424\n    3C4040207C\n    1C2040201C\n    3C4030403C\n    4428102844\n    4C9090907C\n    4464544C44\n    0008364100\n    0000770000\n    0041360800\n    0201020402\n    3C2623263C\n    1EA1A16112\n    3A4040207A\n    3854545559\n    2155557941\n    2154547841\n    2155547840\n    2054557940\n    0C1E527212\n    3955555559\n    3954545459\n    3955545458\n    0000457C41\n    0002457D42\n    0001457C40\n    F0292429F0\n    F0282528F0\n    7C54554500\n    2054547C54\n    7C0A097F49\n    3249494932\n    3248484832\n    324A484830\n    3A4141217A\n    3A42402078\n    009DA0A07D\n    3944444439\n    3D4040403D\n    3C24FF2424\n    487E494366\n    2B2FFC2F2B\n    FF0929F620\n    C0887E0903\n    2054547941\n    0000447D41\n    3048484A32\n    384040227A\n    007A0A0A72\n    7D0D19317D\n    2629292F28\n    2629292926\n    30484D4020\n    3808080808\n    0808080838\n    2F10C8ACBA\n    2F102834FA\n    00007B0000\n    08142A1422\n    22142A1408\n    AA005500AA\n    AA55AA55AA\n    000000FF00\n    101010FF00\n    141414FF00\n    1010FF00FF\n    1010F010F0\n    141414FC00\n    1414F700FF\n    0000FF00FF\n    1414F404FC\n    141417101F\n    10101F101F\n    1414141F00\n    101010F000\n    0000001F10\n    1010101F10\n    101010F010\n    000000FF10\n    1010101010\n    101010FF10\n    000000FF14\n    0000FF00FF\n    00001F1017\n    0000FC04F4\n    1414171017\n    1414F404F4\n    0000FF00F7\n    1414141414\n    1414F700F7\n    1414141714\n    10101F101F\n    141414F414\n    1010F010F0\n    00001F101F\n    0000001F14\n    000000FC14\n    0000F010F0\n    1010FF10FF\n    141414FF14\n    1010101F00\n    000000F010\n    FFFFFFFFFF\n    F0F0F0F0F0\n    FFFFFF0000\n    000000FFFF\n    0F0F0F0F0F\n    3844443844\n    7C2A2A3E14\n    7E02020606\n    027E027E02\n    6355494163\n    3844443C04\n    407E201E20\n    06027E0202\n    99A5E7A599\n    1C2A492A1C\n    4C7201724C\n    304A4D4D30\n    3048784830\n    BC625A463D\n    3E49494900\n    7E0101017E\n    2A2A2A2A2A\n    44445F4444\n    40514A4440\n    40444A5140\n    0000FF0103\n    E080FF0000\n    08086B6B08\n    3612362436\n    060F090F06\n    0000181800\n    0000101000\n    3040FF0101\n    001F01011E\n    00191D1712\n    003C3C3C3C\n    0000000000`\n        loadStarted = false\n        loadPercent = 0\n        clear()\n    }\n\n\n    // Clear the OLED screen\n    /**\n     * Clears everything displayed on the OLED screen, leaving it blank and ready for new content.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_clear_screen\"\n    //% group=\"OLED\"\n    //% block=\"clear OLED display\"\n    //% weight=130 blockGap=8\n    export function clear() {\n        loadStarted = false\n        loadPercent = 0\n        command(SSD1306_SETCOLUMNADRESS)\n        command(0x00)\n        command(displayWidth - 1)\n        command(SSD1306_SETPAGEADRESS)\n        command(0x00)\n        command(displayHeight - 1)\n        let data = pins.createBuffer(17);\n        data[0] = 0x40; // Data Mode\n        for (let i = 1; i < 17; i++) {\n            data[i] = 0x00\n        }\n        // send display buffer in 16 byte chunks\n        for (let i = 0; i < screenSize; i += 16) {\n            pins.i2cWriteBuffer(chipAdress, data, false)\n        }\n        charX = xOffset\n        charY = yOffset\n    }\n\n\n    // Show string at x and y coordinates\n    /**\n     * Displays a string at the specified x and y coordinates on the OLED display.\n     * If the string exceeds the width of the screen, it will continue on the next line.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_write_string\"\n    //% group=\"OLED\"\n    //% block=\"show string at x: $x y: $y with text $str\"\n    //% x.defl=0\n    //% y.defl=0\n    //% weight=120 blockGap=8\n    export function writeStringAt(x: number, y: number, str: string) {\n        let originalX = charX;\n        let originalY = charY;\n        charX = x;\n        charY = y;\n\n        for (let i = 0; i < str.length; i++) {\n            if (charX > displayWidth - 6) {\n                newLine();\n            }\n            drawChar(charX, charY, str.charAt(i));\n            charX += 6;\n        }\n\n        // Reset the cursor back to the original position\n        charX = originalX;\n        charY = originalY;\n    }\n\n    // Show number at x and y coordinates\n    /**\n     * Displays a number at the specified x and y coordinates on the OLED display.\n     * The number is converted to a string before being displayed.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_write_number\"\n    //% group=\"OLED\"\n    //% block=\"show number $n at x: $x y: $y\"\n    //% weight=110 blockGap=8\n    export function writeNumAt(x: number, y: number, n: number) {\n        let numString = n.toString();  // Convert the number to a string\n        let charX = x;  // Starting X coordinate\n        let charY = y;  // Starting Y coordinate\n\n        // Loop through each character of the number string and display it at the coordinates\n        for (let i = 0; i < numString.length; i++) {\n            if (charX > displayWidth - 6) {\n                newLine();\n            }\n            drawChar(charX, charY, numString.charAt(i));\n            charX += 6;  // Move to the next character position\n        }\n    }\n\n    function newLine() {\n        charY++\n        charX = xOffset\n    }\n    function drawChar(x: number, y: number, c: string) {\n        command(SSD1306_SETCOLUMNADRESS)\n        command(x)\n        command(x + 5)\n        command(SSD1306_SETPAGEADRESS)\n        command(y)\n        command(y + 1)\n        let line = pins.createBuffer(2)\n        line[0] = 0x40\n        for (let i = 0; i < 6; i++) {\n            if (i === 5) {\n                line[1] = 0x00\n            } else {\n                let charIndex = c.charCodeAt(0)\n                let charNumber = font.getNumber(NumberFormat.UInt8BE, 5 * charIndex + i)\n                line[1] = charNumber\n\n            }\n            pins.i2cWriteBuffer(chipAdress, line, false)\n        }\n\n    }\n    function drawShape(pixels: Array<Array<number>>) {\n        let x1 = displayWidth\n        let y1 = displayHeight * 8\n        let x2 = 0\n        let y2 = 0\n        for (let i = 0; i < pixels.length; i++) {\n            if (pixels[i][0] < x1) {\n                x1 = pixels[i][0]\n            }\n            if (pixels[i][0] > x2) {\n                x2 = pixels[i][0]\n            }\n            if (pixels[i][1] < y1) {\n                y1 = pixels[i][1]\n            }\n            if (pixels[i][1] > y2) {\n                y2 = pixels[i][1]\n            }\n        }\n        let page1 = Math.floor(y1 / 8)\n        let page2 = Math.floor(y2 / 8)\n        let line = pins.createBuffer(2)\n        line[0] = 0x40\n        for (let x = x1; x <= x2; x++) {\n            for (let page = page1; page <= page2; page++) {\n                line[1] = 0x00\n                for (let i = 0; i < pixels.length; i++) {\n                    if (pixels[i][0] === x) {\n                        if (Math.floor(pixels[i][1] / 8) === page) {\n                            line[1] |= Math.pow(2, (pixels[i][1] % 8))\n                        }\n                    }\n                }\n                if (line[1] !== 0x00) {\n                    command(SSD1306_SETCOLUMNADRESS)\n                    command(x)\n                    command(x + 1)\n                    command(SSD1306_SETPAGEADRESS)\n                    command(page)\n                    command(page + 1)\n                    //line[1] |= pins.i2cReadBuffer(chipAdress, 2)[1]\n                    pins.i2cWriteBuffer(chipAdress, line, false)\n                }\n            }\n        }\n    }\n\n\n    // Draw a line from (x0, y0) to (x1, y1)\n    /**\n     * Draws a line between the two specified points on the OLED screen.\n     * The line is drawn using Bresenham's line algorithm.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_draw_line\"\n    //% group=\"OLED\"\n    //% block=\"draw line from:|x: $x0 y: $y0 to| x: $x1 y: $y1\"\n    //% x0.defl=0\n    //% y0.defl=0\n    //% x1.defl=20\n    //% y1.defl=20\n    //% weight=100 blockGap=8\n    export function drawLine(x0: number, y0: number, x1: number, y1: number) {\n        let pixels: Array<Array<number>> = []\n        let kx: number, ky: number, c: number, i: number, xx: number, yy: number, dx: number, dy: number;\n        let targetX = x1\n        let targetY = y1\n        x1 -= x0; kx = 0; if (x1 > 0) kx = +1; if (x1 < 0) { kx = -1; x1 = -x1; } x1++;\n        y1 -= y0; ky = 0; if (y1 > 0) ky = +1; if (y1 < 0) { ky = -1; y1 = -y1; } y1++;\n        if (x1 >= y1) {\n            c = x1\n            for (i = 0; i < x1; i++, x0 += kx) {\n                pixels.push([x0, y0])\n                c -= y1; if (c <= 0) { if (i != x1 - 1) pixels.push([x0 + kx, y0]); c += x1; y0 += ky; if (i != x1 - 1) pixels.push([x0, y0]); }\n                if (pixels.length > 20) {\n                    drawShape(pixels)\n                    pixels = []\n                    drawLine(x0, y0, targetX, targetY)\n                    return\n                }\n            }\n        } else {\n            c = y1\n            for (i = 0; i < y1; i++, y0 += ky) {\n                pixels.push([x0, y0])\n                c -= x1; if (c <= 0) { if (i != y1 - 1) pixels.push([x0, y0 + ky]); c += y1; x0 += kx; if (i != y1 - 1) pixels.push([x0, y0]); }\n                if (pixels.length > 20) {\n                    drawShape(pixels)\n                    pixels = []\n                    drawLine(x0, y0, targetX, targetY)\n                    return\n                }\n            }\n        }\n        drawShape(pixels)\n    }\n\n    /**\n     * Draws a rectangle on the OLED display from the starting point (x0, y0) to the end point (x1, y1).\n     * The rectangle is drawn by drawing four lines: top, bottom, left, and right.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_draw_rectangle\"\n    //% group=\"OLED\"\n    //% block=\"draw rectangle from:|x: $x0 y: $y0 to| x: $x1 y: $y1\"\n    //% x0.defl=0\n    //% y0.defl=0\n    //% x1.defl=20\n    //% y1.defl=20\n    //% weight=90 blockGap=8\n    export function drawRectangle(x0: number, y0: number, x1: number, y1: number) {\n        drawLine(x0, y0, x1, y0)\n        drawLine(x0, y1, x1, y1)\n        drawLine(x0, y0, x0, y1)\n        drawLine(x1, y0, x1, y1)\n    }\n\n\n    // Draw a circle at (x, y) with radius r\n    /**\n     * Draws a circle at the specified coordinates (x, y) with the given radius.\n     * The circle is drawn by plotting points along the circumference.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_draw_circle\"\n    //% group=\"OLED\"\n    //% block=\"draw circle at x: $x y: $y radius: $r\"\n    //% x.defl=64\n    //% y.defl=32\n    //% r.defl=10\n    //% weight=80 blockGap=8\n    export function drawCircle(x: number, y: number, r: number) {\n        let theta = 0;\n        let step = Math.PI / 90;  // Adjust step for smoothness\n        let pixels: Array<Array<number>> = [];\n\n        while (theta < 2 * Math.PI) {\n            let xPos = Math.floor(x + r * Math.cos(theta));\n            let yPos = Math.floor(y + r * Math.sin(theta));\n            pixels.push([xPos, yPos]);\n            theta += step;\n        }\n\n        drawShape(pixels);\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n\n\n    ////////////////////\n    //  Rainbow BLOCKS  //\n    ////////////////////\n\n    let rainbowBuffer: Buffer = null; // LED data buffer\n    let rainbowNumLeds: number = 24;  // Number of LEDs\n    let rainbowBrightness: number = 255; // Default brightness\n\n\n    /**\n     * Initialize the Rainbow strip\n     * @param numLeds number of LEDs in the strip\n     */\n\n    //% blockId=\"rainbow_initialize\"\n    //% subcategory=\"Rainbow\"\n    //% block=\"initialize Rainbow with %numLeds|LEDs\"\n    //% weight=145 blockGap=8\n    export function initializeRainbow(numLeds: number): void {\n        rainbowNumLeds = numLeds;\n        rainbowBuffer = control.createBuffer(numLeds * 3);\n        clearRainbow(); // Ensure all LEDs start off\n    }\n\n\n\n    /**\n     * Show data on the Rainbow LEDs connected to P2\n    */\n    function showRainbowBuffer(): void {\n        if (rainbowBuffer) {\n            light.sendWS2812Buffer(rainbowBuffer, DigitalPin.P2); // Using P2 for Rainbow connection\n        }\n    }\n\n\n    /**\n     * Show rainbow colors on the strip\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_show_rainbow\"\n    //% block=\"show Rainbow\"\n    //% weight=140 blockGap=8\n    export function showRainbow(): void {\n        if (rainbowBuffer) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                let angle = (i / rainbowNumLeds) * 2 * Math.PI;\n                let red = Math.max(0, Math.sin(angle + (1 / 3) * Math.PI) * 127 + 128);\n                let green = Math.max(0, Math.sin(angle + (2 / 3) * Math.PI) * 127 + 128);\n                let blue = Math.max(0, Math.sin(angle + (4 / 3) * Math.PI) * 127 + 128);\n                setRainbowLedColorRaw(i, Math.floor(red), Math.floor(green), Math.floor(blue));\n            }\n            showRainbowBuffer();\n        }\n    }\n\n    /**\n     * Clear all LEDs on the strip\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_clear\"\n    //% block=\"clear Rainbow\"\n    //% weight=130 blockGap=8\n    export function clearRainbow(): void {\n        if (rainbowBuffer) {\n            rainbowBuffer.fill(0);\n            showRainbowBuffer();\n        }\n    }\n\n    /**\n     * Set color of all LEDs on the strip\n     * @param color the color to set\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#ff0000'\n    //% blockId=\"rainbow_set_color\"\n    //% block=\"set Rainbow color to %color\"\n    //% weight=120 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setRainbowColor(color: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            setRainbowLedColorRaw(i, red, green, blue);\n        }\n        showRainbowBuffer();\n    }\n\n    /**\n     * Set color of a specific LED on the strip\n     * @param ledIndex the index of the LED to change\n     * @param color the color to set\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#ff0000'\n    //% blockId=\"rainbow_set_led_color\"\n    //% block=\"set Rainbow LED %ledIndex|color to %color\"\n    //% weight=110 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setRainbowLedColor(ledIndex: number, color: number): void {\n        if (rainbowBuffer && ledIndex < rainbowNumLeds) {\n            let red = (color >> 16) & 0xFF;\n            let green = (color >> 8) & 0xFF;\n            let blue = color & 0xFF;\n\n            let index = ledIndex * 3; // Calculate position in buffer\n            rainbowBuffer.setUint8(index, (red * rainbowBrightness) >> 8); // Scale brightness\n            rainbowBuffer.setUint8(index + 1, (green * rainbowBrightness) >> 8); // Scale brightness\n            rainbowBuffer.setUint8(index + 2, (blue * rainbowBrightness) >> 8); // Scale brightness\n\n            showRainbowBuffer(); // Send updated buffer to the LEDs\n        }\n    }\n\n    /**\n     * Set brightness of the strip\n     * @param brightness brightness level (0-255)\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_set_brightness\"\n    //% block=\"set Rainbow brightness to %brightness\"\n    //% weight=100 blockGap=8\n    export function setRainbowBrightness(brightness: number): void {\n        rainbowBrightness = Math.clamp(0, 255, brightness);\n        applyRainbowBrightness(); // Apply brightness scaling to the buffer\n        showRainbowBuffer(); // Update LEDs with adjusted brightness\n    }\n\n    /**\n     * Apply brightness scaling to the buffer\n     */\n    function applyRainbowBrightness(): void {\n        if (!rainbowBuffer) return;\n\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            let index = i * 3;\n            rainbowBuffer[index] = (rainbowBuffer[index] * rainbowBrightness) >> 8; // Scale Green\n            rainbowBuffer[index + 1] = (rainbowBuffer[index + 1] * rainbowBrightness) >> 8; // Scale Red\n            rainbowBuffer[index + 2] = (rainbowBuffer[index + 2] * rainbowBrightness) >> 8; // Scale Blue\n        }\n    }\n\n    /**\n     * Set color of a specific LED using raw RGB values\n     * @param ledIndex the index of the LED to change\n     * @param red Red value (0-255)\n     * @param green Green value (0-255)\n     * @param blue Blue value (0-255)\n     */\n    function setRainbowLedColorRaw(index: number, red: number, green: number, blue: number): void {\n        if (!rainbowBuffer || index >= rainbowNumLeds) return;\n\n        let brightnessScale = rainbowBrightness / 255; // Scale factor for brightness\n        rainbowBuffer[index * 3 + 0] = Math.floor(green * brightnessScale); // GRB: Green\n        rainbowBuffer[index * 3 + 1] = Math.floor(red * brightnessScale);   // GRB: Red\n        rainbowBuffer[index * 3 + 2] = Math.floor(blue * brightnessScale);  // GRB: Blue\n    }\n\n    /**\n     * Show a gradient pattern on the strip\n     * @param startHue the starting hue value (0-360)\n     * @param length the length of the gradient in number of LEDs\n     * @param fromColor starting color of the gradient\n     * @param toColor ending color of the gradient\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#ff0000' \n    //% blockId=\"rainbow_gradient\"\n    //% block=\"show gradient with start hue %startHue|length %length|from %fromColor|to %toColor\"\n    //% weight=90 blockGap=8\n    //% fromColor.shadow=\"brightColorNumberPicker\" \n    //% toColor.shadow=\"brightColorNumberPicker\"\n    export function showRainbowGradient(startHue: number, length: number, fromColor: number, toColor: number): void {\n        for (let i = 0; i < length; i++) {\n            let blendColor = blendColors(fromColor, toColor, i / length);\n            setRainbowLedColor(i, blendColor); // Custom function to set LED color\n        }\n        showRainbowBuffer(); // Custom function to apply changes\n    }\n\n    /**\n     * Helper function to blend two colors\n     * @param color1 the first color\n     * @param color2 the second color\n     * @param blend the blend factor between the two colors (0-1)\n     */\n    function blendColors(color1: number, color2: number, blend: number): number {\n        let r1 = (color1 >> 16) & 0xFF;\n        let g1 = (color1 >> 8) & 0xFF;\n        let b1 = color1 & 0xFF;\n\n        let r2 = (color2 >> 16) & 0xFF;\n        let g2 = (color2 >> 8) & 0xFF;\n        let b2 = color2 & 0xFF;\n\n        let r = Math.round(r1 * (1 - blend) + r2 * blend);\n        let g = Math.round(g1 * (1 - blend) + g2 * blend);\n        let b = Math.round(b1 * (1 - blend) + b2 * blend);\n\n        return (r << 16) | (g << 8) | b;\n    }\n\n\n    /**\n     * Custom color picker with all specified colors\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#CCFF00'\n    //% weight=80 blockGap=15\n    //% blockId=brightColorNumberPicker block=\"%value\"\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.colours='[\"#CCFF00\",\"#CCCC00\",\"#CC9900\",\"#CC6600\",\"#CC3300\",\"#CC0000\",\"#660000\",\"#663300\",\"#666600\",\"#669900\",\"#66CC00\",\"#66FF00\",\"#00FF00\",\"#00CC00\",\"#009900\",\"#006600\",\"#003300\",\"#000000\",\"#CCFF33\",\"#CCCC33\",\"#CC9933\",\"#CC6633\",\"#CC3333\",\"#CC0033\",\"#660033\",\"#663333\",\"#666633\",\"#669933\",\"#66CC33\",\"#66FF33\",\"#00FF33\",\"#00CC33\",\"#009933\",\"#006633\",\"#003333\",\"#000033\",\"#CCFF66\",\"#CCCC66\",\"#CC9966\",\"#CC6666\",\"#CC3366\",\"#CC0066\",\"#660066\",\"#663366\",\"#666666\",\"#669966\",\"#66CC66\",\"#66FF66\",\"#00FF66\",\"#00CC66\",\"#009966\",\"#006666\",\"#003366\",\"#000066\",\"#CCFF99\",\"#CCCC99\",\"#CC9999\",\"#CC6699\",\"#CC3399\",\"#CC0099\",\"#660099\",\"#663399\",\"#666699\",\"#669999\",\"#66CC99\",\"#66FF99\",\"#00FF99\",\"#00CC99\",\"#009999\",\"#006699\",\"#003399\",\"#000099\",\"#CCFFCC\",\"#CCCCCC\",\"#CC99CC\",\"#CC66CC\",\"#CC33CC\",\"#CC00CC\",\"#6600CC\",\"#6633CC\",\"#6666CC\",\"#6699CC\",\"#66CCCC\",\"#66FFCC\",\"#00FFCC\",\"#00CCCC\",\"#0099CC\",\"#0066CC\",\"#0033CC\",\"#0000CC\",\"#CCFFFF\",\"#CCCCFF\",\"#CC99FF\",\"#CC66FF\",\"#CC33FF\",\"#CC00FF\",\"#6600FF\",\"#6633FF\",\"#6666FF\",\"#6699FF\",\"#66CCFF\",\"#66FFFF\",\"#00FFFF\",\"#00CCFF\",\"#0099FF\",\"#0066FF\",\"#0033FF\",\"#0000FF\",\"#FFFFFF\",\"#FFCCFF\",\"#FF99FF\",\"#FF66FF\",\"#FF33FF\",\"#FF00FF\",\"#9900FF\",\"#9933FF\",\"#9966FF\",\"#9999FF\",\"#99CCFF\",\"#99FFFF\",\"#33FFFF\",\"#33CCFF\",\"#3399FF\",\"#3366FF\",\"#3333FF\",\"#3300FF\",\"#FFFFCC\",\"#FFCCCC\",\"#FF99CC\",\"#FF66CC\",\"#FF33CC\",\"#FF00CC\",\"#9900CC\",\"#9933CC\",\"#9966CC\",\"#9999CC\",\"#99CCCC\",\"#99FFCC\",\"#33FFCC\",\"#33CCCC\",\"#3399CC\",\"#3366CC\",\"#3333CC\",\"#3300CC\",\"#FFFF99\",\"#FFCC99\",\"#FF9999\",\"#FF6699\",\"#FF3399\",\"#FF0099\",\"#990099\",\"#993399\",\"#996699\",\"#999999\",\"#99CC99\",\"#99FF99\",\"#33FF99\",\"#33CC99\",\"#339999\",\"#336699\",\"#333399\",\"#330099\",\"#FFFF66\",\"#FFCC66\",\"#FF9966\",\"#FF6666\",\"#FF3366\",\"#FF0066\",\"#990066\",\"#993366\",\"#996666\",\"#999966\",\"#99CC66\",\"#99FF66\",\"#33FF66\",\"#33CC66\",\"#339966\",\"#336666\",\"#333366\",\"#330066\",\"#FFFF33\",\"#FFCC33\",\"#FF9933\",\"#FF6633\",\"#FF3333\",\"#FF0033\",\"#990033\",\"#993333\",\"#996633\",\"#999933\",\"#99CC33\",\"#99FF33\",\"#33FF33\",\"#33CC33\",\"#339933\",\"#336633\",\"#333333\",\"#330033\"]'\n    //% value.fieldOptions.columns=18 value.fieldOptions.className='rgbColorPicker'\n    export function rainbowColorPicker(value: number): number {\n        return value;\n    }\n\n    /**\n     * Get a random color\n     */\n    //% blockId=\"rainbow_random_color\"\n    //% value.defl='#ff0000' \n    //% weight=70 blockGap=15\n    //% block=\"random color\"\n    //% subcategory=\"Rainbow\"\n    export function rainbowRandomColor(): number {\n        return Math.randomRange(0, 0xFFFFFF);\n    }\n\n    /**\n     * Convert RGB values to a color number\n     * @param r Red value (0-255)\n     * @param g Green value (0-255)\n     * @param b Blue value (0-255)\n     */\n    //% blockId=\"rainbow_rgb_to_color\"\n    //% value.defl='#ff0000' \n    //% weight=60 blockGap=15\n    //% block=\"R %r|G %g|B %b\"\n    //% r.min=0 r.max=255\n    //% g.min=0 g.max=255\n    //% b.min=0 b.max=255\n    //% subcategory=\"Rainbow\"\n    export function rainbowRgbToColor(r: number, g: number, b: number): number {\n        return (r << 16) | (g << 8) | b;\n    }\n\n    /**\n     * Convert HSL values to a color number\n     * @param h Hue (0-360)\n     * @param s Saturation (0-100)\n     * @param l Luminosity (0-100)\n     */\n    //% blockId=\"rainbow_hsl_to_color\"\n    //% value.defl='#ff0000' \n    //% weight=50 blockGap=15\n    //% subcategory=\"Rainbow\"\n    //% block=\"hue %h|saturation %s|luminosity %l\"\n    //% h.min=0 h.max=360\n    //% s.min=0 s.max=100\n    //% l.min=0 l.max=100\n    export function rainbowHslToColor(h: number, s: number, l: number): number {\n        return rainbowHslToRgb(h, s, l); // Custom function for HSL to RGB\n    }\n\n    /**\n     * Convert HSL values to RGB\n     * @param h Hue (0-360)\n     * @param s Saturation (0-100)\n     * @param l Luminosity (0-100)\n     * @returns A packed RGB number (24-bit)\n     */\n    function rainbowHslToRgb(h: number, s: number, l: number): number {\n        h = h % 360; // Ensure hue wraps around 360\n        s = s / 100; // Convert saturation to a decimal\n        l = l / 100; // Convert luminosity to a decimal\n\n        const c = (1 - Math.abs(2 * l - 1)) * s; // Chroma\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1)); // Second largest component\n        const m = l - c / 2;\n\n        let r = 0, g = 0, b = 0;\n\n        if (h >= 0 && h < 60) {\n            r = c; g = x; b = 0;\n        } else if (h >= 60 && h < 120) {\n            r = x; g = c; b = 0;\n        } else if (h >= 120 && h < 180) {\n            r = 0; g = c; b = x;\n        } else if (h >= 180 && h < 240) {\n            r = 0; g = x; b = c;\n        } else if (h >= 240 && h < 300) {\n            r = x; g = 0; b = c;\n        } else if (h >= 300 && h < 360) {\n            r = c; g = 0; b = x;\n        }\n\n        // Convert RGB components to 8-bit values and pack into a single integer\n        const red = Math.round((r + m) * 255);\n        const green = Math.round((g + m) * 255);\n        const blue = Math.round((b + m) * 255);\n\n        return (red << 16) | (green << 8) | blue;\n    }\n\n    /**\n     * Custom function to set a specific LED's color on the rainbow LED strip\n     * @param index LED index\n     * @param color RGB color\n     */\n    function rainbowSetLedColor(index: number, color: number): void {\n        // Send the appropriate signal to the LEDs\n        let r = (color >> 16) & 0xFF;\n        let g = (color >> 8) & 0xFF;\n        let b = color & 0xFF;\n\n        // Logic to send r, g, and b to the specific LED\n        rainbowSendSignalToLed(index, r, g, b);\n    }\n\n    /**\n     * Function to send RGB signal to a specific LED in the rainbow strip\n     */\n    function rainbowSendSignalToLed(index: number, r: number, g: number, b: number): void {\n        // Use custom bit-banging logic or timing logic here\n    }\n\n    /**\n     * Function to apply updates to the rainbow LEDs\n     */\n    function rainbowUpdateLeds(): void {\n        // Trigger any necessary latch or update commands for the LEDs\n    }\n\n    /**\n     * Breathing effect on the Rainbow strip.\n     * The LED brightness will gradually increase and decrease, creating a \"breathing\" effect.\n     * @param duration The total duration for the breathing cycle in seconds.\n     * @param color The color for the breathing effect.\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_breathing_effect\"\n    //% block=\"start breathing effect for %duration|seconds with color %color\"\n    //% group=Effects weight=85 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    //% duration.defl=5\n    export function rainbowBreathingEffect(duration: number, color: number): void {\n        let cycleTime = (duration * 1000) / 2; // Convert seconds to milliseconds and split into fade-in and fade-out\n        let steps = 255; // Number of steps for fading (brightness from 0 to 255)\n        let stepTime = cycleTime / steps; // Time per step in milliseconds\n\n        // Gradually increase brightness (fade-in)\n        for (let brightness = 0; brightness <= 255; brightness++) {\n            setRainbowBrightness(brightness); // Set brightness\n            applyRainbowColor(color);        // Apply the selected color\n            basic.pause(stepTime);\n        }\n\n        // Gradually decrease brightness (fade-out)\n        for (let brightness = 255; brightness >= 0; brightness--) {\n            setRainbowBrightness(brightness); // Set brightness\n            applyRainbowColor(color);        // Apply the selected color\n            basic.pause(stepTime);\n        }\n    }\n\n    /**\n     * Apply the selected color to the Rainbow LED strip\n     * @param color The color to set\n     */\n    function applyRainbowColor(color: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            setRainbowLedColorRaw(i, red, green, blue);\n        }\n        showRainbowBuffer(); // Refresh the LEDs\n    }\n\n\n    /**\n     * Color Wipe effect on the Rainbow strip.\n     * LEDs light up one by one in a selected color.\n     * @param color the color to wipe\n     * @param delay time between each LED lighting in ms\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_color_wipe\"\n    //% block=\"color wipe with %color|delay %delay s\"\n    //% group=Effects weight=80 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowColorWipe(color: number, delay: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            setRainbowLedColorRaw(i, red, green, blue);\n            showRainbowBuffer();\n            basic.pause(delay * 1000);\n        }\n    }\n\n    /**\n     * Rainbow cycle effect on the Rainbow strip.\n     * Displays a smooth rainbow transition across all LEDs.\n     * @param duration total duration of the rainbow cycle in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_rainbow_cycle\"\n    //% block=\"rainbow cycle for %duration s\"\n    //% group=Effects weight=75 blockGap=8\n    export function rainbowCycle(duration: number): void {\n        let steps = 255; // Number of color steps\n        let stepTime = (duration * 1000) / steps; // Time per step in ms\n\n        for (let j = 0; j < steps; j++) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                let color = wheel((i * 256 / rainbowNumLeds + j) & 255);\n                let red = (color >> 16) & 0xFF;\n                let green = (color >> 8) & 0xFF;\n                let blue = color & 0xFF;\n                setRainbowLedColorRaw(i, red, green, blue);\n            }\n            showRainbowBuffer();\n            basic.pause(stepTime);\n        }\n    }\n\n    /**\n     * Helper function to generate a color from the wheel position\n     * @param position wheel position (0-255)\n     */\n    function wheel(position: number): number {\n        if (position < 85) {\n            return (position * 3 << 16) | ((255 - position * 3) << 8);\n        } else if (position < 170) {\n            position -= 85;\n            return ((255 - position * 3) << 16) | (position * 3);\n        } else {\n            position -= 170;\n            return (position * 3 << 8) | (255 - position * 3);\n        }\n    }\n\n    /**\n     * Twinkle effect on the Rainbow strip.\n     * Random LEDs light up briefly.\n     * @param color the color of the twinkle\n     * @param duration total duration of the twinkle effect in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_twinkle_effect\"\n    //% block=\"twinkle with %color|for %duration s\"\n    //% group=Effects weight=70 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowTwinkle(color: number, duration: number): void {\n        let endTime = input.runningTime() + duration * 1000;\n        while (input.runningTime() < endTime) {\n            let index = Math.randomRange(0, rainbowNumLeds - 1);\n            let red = (color >> 16) & 0xFF;\n            let green = (color >> 8) & 0xFF;\n            let blue = color & 0xFF;\n\n            setRainbowLedColorRaw(index, red, green, blue);\n            showRainbowBuffer();\n            basic.pause(100);\n\n            setRainbowLedColorRaw(index, 0, 0, 0); // Turn off the LED\n            showRainbowBuffer();\n            basic.pause(100);\n        }\n    }\n\n\n    /**\n     * Theater Chase effect on the Rainbow strip.\n     * A pattern of moving dots in a specific color.\n     * @param color the color of the chase\n     * @param duration total duration of the chase effect in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_theater_chase\"\n    //% block=\"theater chase with color %color|for %duration|s\"\n    //% group=Effects weight=65 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowTheaterChase(color: number, duration: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n\n        let endTime = input.runningTime() + duration * 1000; // Duration in milliseconds\n\n        while (input.runningTime() < endTime) {\n            for (let q = 0; q < 3; q++) {\n                // Light up every 3rd LED starting at position q\n                for (let i = 0; i < rainbowNumLeds; i += 3) {\n                    let index = i + q;\n                    if (index < rainbowNumLeds) {\n                        setRainbowLedColorRaw(index, red, green, blue);\n                    }\n                }\n                showRainbowBuffer();\n                basic.pause(50);\n\n                // Turn off the same LEDs\n                for (let i = 0; i < rainbowNumLeds; i += 3) {\n                    let index = i + q;\n                    if (index < rainbowNumLeds) {\n                        setRainbowLedColorRaw(index, 0, 0, 0); // Turn off the LED\n                    }\n                }\n                showRainbowBuffer();\n                basic.pause(50);\n            }\n        }\n\n        // Clear all LEDs after the duration ends\n        clearRainbow();\n    }\n\n    /**\n     * Wave effect on the Rainbow strip.\n     * Brightness varies across the strip in a sine wave pattern.\n     * @param color the base color of the wave\n     * @param duration total duration of the wave effect in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_wave_effect\"\n    //% block=\"wave effect with %color|for %duration s\"\n    //% group=Effects weight=60 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowWave(color: number, duration: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n\n        let steps = 255;\n        let stepTime = (duration * 1000) / steps;\n\n        for (let j = 0; j < steps; j++) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                let brightness = (Math.sin((i + j) * Math.PI / 180) + 1) * 127.5; // Sine wave\n                setRainbowLedColorRaw(i, (red * brightness) / 255, (green * brightness) / 255, (blue * brightness) / 255);\n            }\n            showRainbowBuffer();\n            basic.pause(stepTime);\n        }\n    }\n}\n"}]},{"timestamp":1735213978637,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"225"],[1,"0"],[0,"\" y=\""],[-1,"2"],[0,"0\"><"]],"start1":106,"start2":106,"length1":17,"length2":14}]}]},{"timestamp":1735215345219,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":276,"start2":276,"length1":21,"length2":17}]}]},{"timestamp":1735215345495,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"er\" "],[-1,"id=\"pjnSXn.0l[xdp-X:q]G+\" x=\"0"],[1,"x=\"225"],[0,"\" y=\""],[1,"2"],[0,"0\"><"]],"start1":103,"start2":103,"length1":43,"length2":20}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":256,"start2":256,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1735213485294,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Onebit_APDS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1735215345219,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"0\" y=\"0\"></block></xml>","main.ts":"basic.forever(function () {\n\t\n})\n","README.md":"","Onebit_APDS.ts":"/**\n * Custom blocks for One:Bit\n */\n\n\nconst gestureRightID = 4101;\nconst gestureLeftID = 4102;\nconst gestureUpID = 4103;\nconst gestureDownID = 4104;\nconst gestureForwardID = 4105;\nconst gestureBackwardID = 4106;\n\nlet DEBUG = 0;\n/* APDS-9960 I2C address */\nlet APDS9960_I2C_ADDR = 0x39\n\n/* Gesture parameters */\nlet GESTURE_THRESHOLD_OUT = 30\nlet GESTURE_SENSITIVITY_1 = 33\nlet GESTURE_SENSITIVITY_2 = 18\n\n/* Error code for returned values */\nlet ERROR = 0xFF\n\n/* Acceptable device IDs */\nlet APDS9960_ID_1 = 0xA8\nlet APDS9960_ID_2 = 0x9C\n\n/* Misc parameters */\nlet FIFO_PAUSE_TIME = 30      // Wait period (ms) between FIFO reads\n\n/* APDS-9960 register addresses */\nlet APDS9960_ENABLE = 0x80\nlet APDS9960_ATIME = 0x81\nlet APDS9960_WTIME = 0x83\nlet APDS9960_AILTL = 0x84\nlet APDS9960_AILTH = 0x85\nlet APDS9960_AIHTL = 0x86\nlet APDS9960_AIHTH = 0x87\nlet APDS9960_PILT = 0x89\nlet APDS9960_PIHT = 0x8B\nlet APDS9960_PERS = 0x8C\nlet APDS9960_CONFIG1 = 0x8D\nlet APDS9960_PPULSE = 0x8E\nlet APDS9960_CONTROL = 0x8F\nlet APDS9960_CONFIG2 = 0x90\nlet APDS9960_ID = 0x92\nlet APDS9960_STATUS = 0x93\nlet APDS9960_CDATAL = 0x94\nlet APDS9960_CDATAH = 0x95\nlet APDS9960_RDATAL = 0x96\nlet APDS9960_RDATAH = 0x97\nlet APDS9960_GDATAL = 0x98\nlet APDS9960_GDATAH = 0x99\nlet APDS9960_BDATAL = 0x9A\nlet APDS9960_BDATAH = 0x9B\nlet APDS9960_PDATA = 0x9C\nlet APDS9960_POFFSET_UR = 0x9D\nlet APDS9960_POFFSET_DL = 0x9E\nlet APDS9960_CONFIG3 = 0x9F\nlet APDS9960_GPENTH = 0xA0\nlet APDS9960_GEXTH = 0xA1\nlet APDS9960_GCONF1 = 0xA2\nlet APDS9960_GCONF2 = 0xA3\nlet APDS9960_GOFFSET_U = 0xA4\nlet APDS9960_GOFFSET_D = 0xA5\nlet APDS9960_GOFFSET_L = 0xA7\nlet APDS9960_GOFFSET_R = 0xA9\nlet APDS9960_GPULSE = 0xA6\nlet APDS9960_GCONF3 = 0xAA\nlet APDS9960_GCONF4 = 0xAB\nlet APDS9960_GFLVL = 0xAE\nlet APDS9960_GSTATUS = 0xAF\nlet APDS9960_IFORCE = 0xE4\nlet APDS9960_PICLEAR = 0xE5\nlet APDS9960_CICLEAR = 0xE6\nlet APDS9960_AICLEAR = 0xE7\nlet APDS9960_GFIFO_U = 0xFC\nlet APDS9960_GFIFO_D = 0xFD\nlet APDS9960_GFIFO_L = 0xFE\nlet APDS9960_GFIFO_R = 0xFF\n\n/* Bit fields */\nlet APDS9960_PON = 0b00000001\nlet APDS9960_AEN = 0b00000010\nlet APDS9960_PEN = 0b00000100\nlet APDS9960_WEN = 0b00001000\nlet APSD9960_AIEN = 0b00010000\nlet APDS9960_PIEN = 0b00100000\nlet APDS9960_GEN = 0b01000000\nlet APDS9960_GVALID = 0b00000001\n\n/* On/Off definitions */\nlet OFF = 0\nlet ON = 1\n\n/* Acceptable parameters for setMode */\nlet POWER = 0\nlet AMBIENT_LIGHT = 1\nlet PROXIMITY = 2\nlet WAIT = 3\nlet AMBIENT_LIGHT_INT = 4\nlet PROXIMITY_INT = 5\nlet GESTURE = 6\nlet ALL = 7\n\n/* LED Drive values */\nlet LED_DRIVE_100MA = 0\nlet LED_DRIVE_50MA = 1\nlet LED_DRIVE_25MA = 2\nlet LED_DRIVE_12_5MA = 3\n\n/* Proximity Gain (PGAIN) values */\nlet PGAIN_1X = 0\nlet PGAIN_2X = 1\nlet PGAIN_4X = 2\nlet PGAIN_8X = 3\n\n/* ALS Gain (AGAIN) values */\nlet AGAIN_1X = 0\nlet AGAIN_4X = 1\nlet AGAIN_16X = 2\nlet AGAIN_64X = 3\n\n/* Gesture Gain (GGAIN) values */\nlet GGAIN_1X = 0\nlet GGAIN_2X = 1\nlet GGAIN_4X = 2\nlet GGAIN_8X = 3\n\n/* LED Boost values */\nlet LED_BOOST_100 = 0\nlet LED_BOOST_150 = 1\nlet LED_BOOST_200 = 2\nlet LED_BOOST_300 = 3\n\n/* Gesture wait time values */\nlet GWTIME_0MS = 0\nlet GWTIME_2_8MS = 1\nlet GWTIME_5_6MS = 2\nlet GWTIME_8_4MS = 3\nlet GWTIME_14_0MS = 4\nlet GWTIME_22_4MS = 5\nlet GWTIME_30_8MS = 6\nlet GWTIME_39_2MS = 7\n\n/* Default values */\nlet DEFAULT_ATIME = 219     // 103ms\nlet DEFAULT_WTIME = 246     // 27ms\nlet DEFAULT_PROX_PPULSE = 0x87    // 16us, 8 pulses\nlet DEFAULT_GESTURE_PPULSE = 0x89    // 16us, 10 pulses\nlet DEFAULT_POFFSET_UR = 0       // 0 offset\nlet DEFAULT_POFFSET_DL = 0       // 0 offset      \nlet DEFAULT_CONFIG1 = 0x60    // No 12x wait (WTIME) factor\nlet DEFAULT_LDRIVE = LED_DRIVE_100MA\nlet DEFAULT_PGAIN = PGAIN_4X\nlet DEFAULT_AGAIN = AGAIN_4X\nlet DEFAULT_PILT = 0       // Low proximity threshold\nlet DEFAULT_PIHT = 50      // High proximity threshold\nlet DEFAULT_AILT = 0xFFFF  // Force interrupt for calibration\nlet DEFAULT_AIHT = 0\nlet DEFAULT_PERS = 0x11    // 2 consecutive prox or ALS for int.\nlet DEFAULT_CONFIG2 = 0x01    // No saturation interrupts or LED boost  \nlet DEFAULT_CONFIG3 = 0       // Enable all photodiodes, no SAI\nlet DEFAULT_GPENTH = 40      // Threshold for entering gesture mode\nlet DEFAULT_GEXTH = 30      // Threshold for exiting gesture mode    \nlet DEFAULT_GCONF1 = 0x40    // 4 gesture events for int., 1 for exit\nlet DEFAULT_GGAIN = GGAIN_4X\nlet DEFAULT_GLDRIVE = LED_DRIVE_100MA\nlet DEFAULT_GWTIME = GWTIME_2_8MS\nlet DEFAULT_GOFFSET = 0       // No offset scaling for gesture mode\nlet DEFAULT_GPULSE = 0xC9    // 32us, 10 pulses\nlet DEFAULT_GCONF3 = 0       // All photodiodes active during gesture\nlet DEFAULT_GIEN = 0       // Disable gesture interrupts\n\n/* Direction definitions */\nenum DIR {\n    DIR_NONE,\n    DIR_RIGHT,\n    DIR_LEFT,\n    DIR_UP,\n    DIR_DOWN,\n    DIR_NEAR,\n    DIR_FAR,\n    DIR_ALL\n}\n\n/* State definitions */\nenum STATE {\n    NA_STATE,\n    NEAR_STATE,\n    FAR_STATE,\n    ALL_STATE\n}\n\nlet gesture_ud_delta: number;\nlet gesture_lr_delta: number;\nlet gesture_ud_count: number;\nlet gesture_lr_count: number;\nlet gesture_near_count: number;\nlet gesture_far_count: number;\nlet gesture_state: number;\nlet gesture_motion: number;\n\n/**\n * Brickcell Gestures\n */\nenum BrickcellGesture {\n    //% Right\n    Right = 1,\n    //% Left\n    Left = 2,\n    //% Up\n    Up = 3,\n    //% Down\n    Down = 4,\n}\n\n\n\n\n\n\n//% weight=100 color=#993366 icon=\"\\uf2db\" block=\"One:Bit\"\nnamespace One_Bit {\n\n    // Define custom enums for digital pins\n    export enum DigitalPinPrime {\n        //% block=\"P0\"\n        P0 = DigitalPin.P0,\n        //% block=\"P1\"\n        P1 = DigitalPin.P1,\n        //% block=\"P2\"\n        P2 = DigitalPin.P2,\n        //% block=\"P3\"\n        P3 = DigitalPin.P3,\n        //% block=\"P4\"\n        P4 = DigitalPin.P4,\n        //% block=\"P9\"\n        P9 = DigitalPin.P9,\n        //% block=\"P10\"\n        P10 = DigitalPin.P10,\n        //% block=\"P13\"\n        P13 = DigitalPin.P13,\n        //% block=\"P14\"\n        P14 = DigitalPin.P14,\n        //% block=\"P15\"\n        P15 = DigitalPin.P15,\n        //% block=\"P19\"\n        P19 = DigitalPin.P19,\n        //% block=\"P20\"\n        P20 = DigitalPin.P20\n    }\n\n    // Define custom enums for analog pins\n    export enum AnalogPinPrime {\n        //% block=\"P0\"\n        P0 = AnalogPin.P0,\n        //% block=\"P1\"\n        P1 = AnalogPin.P1,\n        //% block=\"P2\"\n        P2 = AnalogPin.P2,\n        //% block=\"P3\"\n        P3 = AnalogPin.P3,\n        //% block=\"P4\"\n        P4 = AnalogPin.P4,\n        //% block=\"P10\"\n        P10 = AnalogPin.P10\n    }\n\n\n    // Enum for PWM pins\n    export enum PWM {\n        //% block=\"P0\"\n        P0 = DigitalPin.P0,\n        //% block=\"P1\"\n        P1 = DigitalPin.P1,\n        //% block=\"P2\"\n        P2 = DigitalPin.P2,\n        //% block=\"P8\"\n        P8 = DigitalPin.P8,\n        //% block=\"P12\"\n        P12 = DigitalPin.P12,\n        //% block=\"P13\"\n        P13 = DigitalPin.P13,\n        //% block=\"P14\"\n        P14 = DigitalPin.P14,\n        //% block=\"P15\"\n        P15 = DigitalPin.P15,\n        //% block=\"P16\"\n        P16 = DigitalPin.P16\n    }\n\n\n    ////////////////////\n    //  PRIME BLOCKS  //\n    ////////////////////\n\n    // Function for reading a digital value from a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% weight=150 blockGap=8\n    //% blockId=\"digital_read\"\n    //% block=\"read digital pin %pin\"\n    export function digitalRead(pin: DigitalPinPrime): number {\n        return pins.digitalReadPin(pin);\n    }\n\n    // Function for writing a digital value to a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% blockId=\"digital_write\"\n    //% weight=140 blockGap= 50\n    //% block=\"write digital pin %pin |to %value\"\n    export function digitalWrite(pin: DigitalPinPrime, value: number): void {\n        pins.digitalWritePin(pin, value);\n    }\n\n    // Function for reading an analog value from a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Analog Pins\"\n    //% blockId=\"analog_read\"\n    //% weight=130 blockGap=8\n    //% block=\"read analog pin %pin\"\n    export function analogRead(pin: AnalogPinPrime): number {\n        return pins.analogReadPin(pin);\n    }\n\n    // Function for writing an analog value to a pin\n    //% subcategory=\"Prime\"\n    //% group=\"Analog Pins\"\n    //% weight=120 blockGap=8\n    //% blockId=\"analog_write\"\n    //% block=\"write analog pin %pin |to %value \"\n    //% value.min=0 value.max=1023\n    export function analogWrite(pin: AnalogPinPrime, value: number): void {\n        pins.analogWritePin(pin, value);\n    }\n\n\n\n    let primeBuffer: Buffer = null; // LED data buffer\n    let primeNumLeds: number = 12;  // Number of LEDs\n    let primeBrightness: number = 255; // Default brightness\n\n\n    /**\n     * Initialize the Prime\n     * @param numLeds number of LEDs in the strip\n     */\n    //% subcategory=\"Prime\"\n    //% blockId=\"one_bit_prime_initialize\"\n    //% group=\"Neo_Color\"\n    //% block=\"initialize Prime with %numLeds|LEDs\"\n    //% weight=150 blockGap=8\n    //% blockNamespace=\"One_Bit\"\n    export function initializePrime(numLeds: number): void {\n        primeNumLeds = numLeds;\n        primeBuffer = control.createBuffer(numLeds * 3);\n        clearPrime(); // Ensure all LEDs start off\n    }\n\n    /**\n     * Show data on the LEDs\n     */\n    function showPrimeBuffer(): void {\n        if (primeBuffer) {\n            light.sendWS2812Buffer(primeBuffer, DigitalPin.P16);\n        }\n    }\n\n    /**\n     * Show rainbow colors on the strip\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_show_rainbow\"\n    //% block=\"show Prime\"\n    //% weight=140 blockGap=8\n    export function showPrime(): void {\n        if (primeBuffer) {\n            for (let i = 0; i < primeNumLeds; i++) {\n                let angle = (i / primeNumLeds) * 2 * Math.PI;\n                let red = Math.max(0, Math.sin(angle + (1 / 3) * Math.PI) * 127 + 128);\n                let green = Math.max(0, Math.sin(angle + (2 / 3) * Math.PI) * 127 + 128);\n                let blue = Math.max(0, Math.sin(angle + (4 / 3) * Math.PI) * 127 + 128);\n                setPrimeLedColorRaw(i, Math.floor(red), Math.floor(green), Math.floor(blue));\n            }\n            showPrimeBuffer();\n        }\n    }\n\n    /**\n     * Clear all LEDs on the strip\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_clear\"\n    //% block=\"clear Prime\"\n    //% weight=130 blockGap=8\n    export function clearPrime(): void {\n        if (primeBuffer) {\n            primeBuffer.fill(0);\n            showPrimeBuffer();\n        }\n    }\n\n\n    /**\n     * Set color of all LEDs on the strip\n     * @param color the color to set\n     */\n    //% subcategory=\"Prime\"\n    //% value.defl='#ff0000'\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_set_color\"\n    //% block=\"set Prime color to %color\"\n    //% weight=120 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setPrimeColor(color: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n        for (let i = 0; i < primeNumLeds; i++) {\n            setPrimeLedColorRaw(i, red, green, blue);\n        }\n        showPrimeBuffer();\n    }\n\n    /**\n * Set color of a specific LED on the strip\n * @param ledIndex the index of the LED to change\n * @param color the color to set\n */\n    //% subcategory=\"Prime\"\n    //% value.defl='#FFFFFF'\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_set_led_color\"\n    //% block=\"set Prime LED %ledIndex|color to %color\"\n    //% weight=110 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setPrimeLedColor(ledIndex: number, color: number): void {\n        if (primeBuffer && ledIndex < primeNumLeds) {\n            let red = (color >> 16) & 0xFF;\n            let green = (color >> 8) & 0xFF;\n            let blue = color & 0xFF;\n\n            let index = ledIndex * 3; // Calculate position in buffer\n            primeBuffer.setUint8(index, (red * primeBrightness) >> 8); // Scale brightness\n            primeBuffer.setUint8(index + 1, (green * primeBrightness) >> 8); // Scale brightness\n            primeBuffer.setUint8(index + 2, (blue * primeBrightness) >> 8); // Scale brightness\n\n            showPrimeBuffer(); // Send updated buffer to the LEDs\n        }\n    }\n\n\n    /**\n     * Set brightness of the strip\n     * @param brightness brightness level (0-255)\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_set_brightness\"\n    //% block=\"set Prime brightness to %brightness\"\n    //% weight=100 blockGap=8\n    export function setPrimeBrightness(brightness: number): void {\n        primeBrightness = Math.clamp(0, 255, brightness);\n        applyBrightness(); // Apply brightness scaling to the buffer\n        showPrimeBuffer(); // Update LEDs with adjusted brightness\n    }\n\n    /**\n     * Apply brightness scaling to the buffer\n     */\n    function applyBrightness(): void {\n        if (!primeBuffer) return;\n\n        for (let i = 0; i < primeNumLeds; i++) {\n            let index = i * 3;\n            primeBuffer[index] = (primeBuffer[index] * primeBrightness) >> 8; // Scale Green\n            primeBuffer[index + 1] = (primeBuffer[index + 1] * primeBrightness) >> 8; // Scale Red\n            primeBuffer[index + 2] = (primeBuffer[index + 2] * primeBrightness) >> 8; // Scale Blue\n        }\n    }\n    /**\n     * Set color of a specific LED using raw RGB values\n     * @param ledIndex the index of the LED to change\n     * @param red Red value (0-255)\n     * @param green Green value (0-255)\n     * @param blue Blue value (0-255)\n     */\n    function setPrimeLedColorRaw(index: number, red: number, green: number, blue: number): void {\n        if (!primeBuffer || index >= primeNumLeds) return;\n\n        let brightnessScale = primeBrightness / 255; // Scale factor for brightness\n        primeBuffer[index * 3 + 0] = Math.floor(green * brightnessScale); // GRB: Green\n        primeBuffer[index * 3 + 1] = Math.floor(red * brightnessScale);   // GRB: Red\n        primeBuffer[index * 3 + 2] = Math.floor(blue * brightnessScale);  // GRB: Blue\n    }\n\n    /**\n     * Show a gradient pattern on the strip\n     * @param startHue the starting hue value (0-360)\n     * @param length the length of the gradient in number of LEDs\n     * @param fromColor starting color of the gradient\n     * @param toColor ending color of the gradient\n     */\n    //% subcategory=\"Prime\"\n    //% value.defl=\"#FFFFFF\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_gradient\"\n    //% block=\"show gradient with start hue %startHue|length %length|from %fromColor|to %toColor\"\n    //% weight=90 blockGap=8\n    //% fromColor.shadow=\"brightColorNumberPicker\" \n    //% toColor.shadow=\"brightColorNumberPicker\"\n    export function showPrimeGradient(startHue: number, length: number, fromColor: number, toColor: number): void {\n        for (let i = 0; i < length; i++) {\n            let blendColor = blend(fromColor, toColor, i / length);\n            setLedColor(i, blendColor); // Custom function to set LED color\n        }\n        updateLeds(); // Custom function to apply changes\n    }\n\n\n    /**\n     * Helper function to blend two colors\n     * @param color1 the first color\n     * @param color2 the second color\n     * @param blend the blend factor between the two colors (0-1)\n     */\n    function blend(color1: number, color2: number, blend: number): number {\n        let r1 = (color1 >> 16) & 0xFF;\n        let g1 = (color1 >> 8) & 0xFF;\n        let b1 = color1 & 0xFF;\n\n        let r2 = (color2 >> 16) & 0xFF;\n        let g2 = (color2 >> 8) & 0xFF;\n        let b2 = color2 & 0xFF;\n\n        let r = Math.round(r1 * (1 - blend) + r2 * blend);\n        let g = Math.round(g1 * (1 - blend) + g2 * blend);\n        let b = Math.round(b1 * (1 - blend) + b2 * blend);\n\n        return (r << 16) | (g << 8) | b;\n    }\n\n\n\n    /**\n     * Custom color picker with all specified colors\n     */\n    //% subcategory=\"Prime\"\n    //% value.defl='#CCFF00'\n    //% group=\"Neo_Color\"\n    //% weight=80 blockGap=20\n    //% blockId=brightColorNumberPicker block=\"%value\"\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.colours='[\"#CCFF00\",\"#CCCC00\",\"#CC9900\",\"#CC6600\",\"#CC3300\",\"#CC0000\",\"#660000\",\"#663300\",\"#666600\",\"#669900\",\"#66CC00\",\"#66FF00\",\"#00FF00\",\"#00CC00\",\"#009900\",\"#006600\",\"#003300\",\"#000000\",\"#CCFF33\",\"#CCCC33\",\"#CC9933\",\"#CC6633\",\"#CC3333\",\"#CC0033\",\"#660033\",\"#663333\",\"#666633\",\"#669933\",\"#66CC33\",\"#66FF33\",\"#00FF33\",\"#00CC33\",\"#009933\",\"#006633\",\"#003333\",\"#000033\",\"#CCFF66\",\"#CCCC66\",\"#CC9966\",\"#CC6666\",\"#CC3366\",\"#CC0066\",\"#660066\",\"#663366\",\"#666666\",\"#669966\",\"#66CC66\",\"#66FF66\",\"#00FF66\",\"#00CC66\",\"#009966\",\"#006666\",\"#003366\",\"#000066\",\"#CCFF99\",\"#CCCC99\",\"#CC9999\",\"#CC6699\",\"#CC3399\",\"#CC0099\",\"#660099\",\"#663399\",\"#666699\",\"#669999\",\"#66CC99\",\"#66FF99\",\"#00FF99\",\"#00CC99\",\"#009999\",\"#006699\",\"#003399\",\"#000099\",\"#CCFFCC\",\"#CCCCCC\",\"#CC99CC\",\"#CC66CC\",\"#CC33CC\",\"#CC00CC\",\"#6600CC\",\"#6633CC\",\"#6666CC\",\"#6699CC\",\"#66CCCC\",\"#66FFCC\",\"#00FFCC\",\"#00CCCC\",\"#0099CC\",\"#0066CC\",\"#0033CC\",\"#0000CC\",\"#CCFFFF\",\"#CCCCFF\",\"#CC99FF\",\"#CC66FF\",\"#CC33FF\",\"#CC00FF\",\"#6600FF\",\"#6633FF\",\"#6666FF\",\"#6699FF\",\"#66CCFF\",\"#66FFFF\",\"#00FFFF\",\"#00CCFF\",\"#0099FF\",\"#0066FF\",\"#0033FF\",\"#0000FF\",\"#FFFFFF\",\"#FFCCFF\",\"#FF99FF\",\"#FF66FF\",\"#FF33FF\",\"#FF00FF\",\"#9900FF\",\"#9933FF\",\"#9966FF\",\"#9999FF\",\"#99CCFF\",\"#99FFFF\",\"#33FFFF\",\"#33CCFF\",\"#3399FF\",\"#3366FF\",\"#3333FF\",\"#3300FF\",\"#FFFFCC\",\"#FFCCCC\",\"#FF99CC\",\"#FF66CC\",\"#FF33CC\",\"#FF00CC\",\"#9900CC\",\"#9933CC\",\"#9966CC\",\"#9999CC\",\"#99CCCC\",\"#99FFCC\",\"#33FFCC\",\"#33CCCC\",\"#3399CC\",\"#3366CC\",\"#3333CC\",\"#3300CC\",\"#FFFF99\",\"#FFCC99\",\"#FF9999\",\"#FF6699\",\"#FF3399\",\"#FF0099\",\"#990099\",\"#993399\",\"#996699\",\"#999999\",\"#99CC99\",\"#99FF99\",\"#33FF99\",\"#33CC99\",\"#339999\",\"#336699\",\"#333399\",\"#330099\",\"#FFFF66\",\"#FFCC66\",\"#FF9966\",\"#FF6666\",\"#FF3366\",\"#FF0066\",\"#990066\",\"#993366\",\"#996666\",\"#999966\",\"#99CC66\",\"#99FF66\",\"#33FF66\",\"#33CC66\",\"#339966\",\"#336666\",\"#333366\",\"#330066\",\"#FFFF33\",\"#FFCC33\",\"#FF9933\",\"#FF6633\",\"#FF3333\",\"#FF0033\",\"#990033\",\"#993333\",\"#996633\",\"#999933\",\"#99CC33\",\"#99FF33\",\"#33FF33\",\"#33CC33\",\"#339933\",\"#336633\",\"#333333\",\"#330033\"]'\n    //% value.fieldOptions.columns=18 value.fieldOptions.className='rgbColorPicker'\n    export function __colorNumberPicker(value: number): number {\n        return value;\n    }\n\n\n    /**\n     * Get a random color\n     */\n    //% blockId=\"one_bit_prime_random_color\"\n    //% value.defl='#ff0000' \n    //% group=\"Neo_Color\" weight=70\n    //% block=\"random color\"\n    //% subcategory=\"Prime\"\n    export function primeRandomColor(): number {\n        return Math.randomRange(0, 0xFFFFFF);\n    }\n\n\n    /**\n     * Convert RGB values to a color number\n     * @param r Red value (0-255)\n     * @param g Green value (0-255)\n     * @param b Blue value (0-255)\n     */\n    //% blockId=\"one_bit_prime_rgb_to_color\"\n    //% value.defl='#ff0000' \n    //% group=\"Neo_Color\" weight=60\n    //% block=\"R %r|G %g|B %b\"\n    //% r.min=0 r.max=255\n    //% g.min=0 g.max=255\n    //% b.min=0 b.max=255\n    //% subcategory=\"Prime\"\n    export function primeRgbToColor(r: number, g: number, b: number): number {\n        return (r << 16) | (g << 8) | b;\n    }\n\n    /**\n     * Convert HSL values to a color number\n     * @param h Hue (0-360)\n     * @param s Saturation (0-100)\n     * @param l Luminosity (0-100)\n     */\n    //% blockId=\"one_bit_prime_hsl_to_color\"\n    //% value.defl='#ff0000' \n    //% group=\"Neo_Color\" weight=50\n    //% block=\"hue %h|saturation %s|luminosity %l\"\n    //% h.min=0 h.max=360\n    //% s.min=0 s.max=100\n    //% l.min=0 l.max=100\n    //% subcategory=\"Prime\"\n    export function primeHslToColor(h: number, s: number, l: number): number {\n        return hslToRgb(h, s, l); // Custom function for HSL to RGB\n    }\n\n    /**\n * Convert HSL values to RGB\n * @param h Hue (0-360)\n * @param s Saturation (0-100)\n * @param l Luminosity (0-100)\n * @returns A packed RGB number (24-bit)\n */\n    function hslToRgb(h: number, s: number, l: number): number {\n        h = h % 360; // Ensure hue wraps around 360\n        s = s / 100; // Convert saturation to a decimal\n        l = l / 100; // Convert luminosity to a decimal\n\n        const c = (1 - Math.abs(2 * l - 1)) * s; // Chroma\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1)); // Second largest component\n        const m = l - c / 2;\n\n        let r = 0, g = 0, b = 0;\n\n        if (h >= 0 && h < 60) {\n            r = c; g = x; b = 0;\n        } else if (h >= 60 && h < 120) {\n            r = x; g = c; b = 0;\n        } else if (h >= 120 && h < 180) {\n            r = 0; g = c; b = x;\n        } else if (h >= 180 && h < 240) {\n            r = 0; g = x; b = c;\n        } else if (h >= 240 && h < 300) {\n            r = x; g = 0; b = c;\n        } else if (h >= 300 && h < 360) {\n            r = c; g = 0; b = x;\n        }\n\n        // Convert RGB components to 8-bit values and pack into a single integer\n        const red = Math.round((r + m) * 255);\n        const green = Math.round((g + m) * 255);\n        const blue = Math.round((b + m) * 255);\n\n        return (red << 16) | (green << 8) | blue;\n    }\n\n\n    /**\n     * Custom function to set a specific LED's color\n     * @param index LED index\n     * @param color RGB color\n     */\n    function setLedColor(index: number, color: number): void {\n        // Send the appropriate signal to the LEDs\n        let r = (color >> 16) & 0xFF;\n        let g = (color >> 8) & 0xFF;\n        let b = color & 0xFF;\n\n        // Logic to send r, g, and b to the specific LED\n        sendSignalToLed(index, r, g, b);\n    }\n\n    /**\n     * Function to send RGB signal to a specific LED\n     */\n    function sendSignalToLed(index: number, r: number, g: number, b: number): void {\n        // Use custom bit-banging logic or timing logic here\n    }\n\n    /**\n     * Function to apply updates to the LEDs\n     */\n    function updateLeds(): void {\n        // Trigger any necessary latch or update commands for the LEDs\n    }\n\n\n\n    ////////////////////\n    // Sensors //\n    ////////////////////\n\n    // Enum for Distance Units\n    export enum Unit {\n        //% block=\"cm\"\n        Centimeters,\n        //% block=\"inches\"\n        Inches\n    }\n\n    /**\n     * Initialize Ultrasonic Sensor and get distance\n     * @param trigPin TRIG pin of the sensor\n     * @param echoPin ECHO pin of the sensor\n     * @param unit Desired distance unit\n     * @param maxCmDistance Maximum measurable distance in centimeters (default is 500)\n     */\n    //% blockId=\"initialize_and_get_ultrasonic_distance\" \n    //% block=\"ultrasonic on trig %trigPin|echo %echoPin|distance in %unit\"\n    //% subcategory=\"Sensors\"\n    //% group=\"Ultrasonic Sensor\"\n    //% trigPin.defl=PWM.P0\n    //% echoPin.defl=PWM.P1\n    //% unit.defl=Unit.Centimeters\n    //% weight=100 blockGap=8\n    export function initializeAndGetUltrasonicDistance(\n        trigPin: PWM,\n        echoPin: PWM,\n        unit: Unit,\n        maxCmDistance = 500\n    ): number {\n        // Send pulse to trigger ultrasonic sensor\n        pins.setPull(trigPin, PinPullMode.PullNone);\n        pins.digitalWritePin(trigPin, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(trigPin, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(trigPin, 0);\n\n        // Read pulse duration from echo pin\n        const d = pins.pulseIn(echoPin, PulseValue.High, maxCmDistance * 58);\n\n        // Handle case where no echo is received\n        if (d === 0) {\n            return -1; // Return -1 for no response\n        }\n\n        // Convert pulse duration to distance\n        switch (unit) {\n            case Unit.Centimeters:\n                return Math.idiv(d, 58); // Convert to cm\n            case Unit.Inches:\n                return Math.idiv(d, 148); // Convert to inches\n            default:\n                return -1;\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n\n\n    export enum tempUnit {\n        //% block=\"Celsius (*C)\"\n        celsius,\n        //% block=\"Fahrenheit (*F)\"\n        fahrenheit,\n    }\n\n    let _temperature: number = -999.0\n    let _humidity: number = -999.0\n\n    /**\n    * Read temperature data from DHT11 sensor.\n    * @param pin the pin number where the DHT11 data pin is connected\n    * @param unit the temperature unit to read (Celsius or Fahrenheit)\n    */\n    //% blockId=\"dht11_temperature\"\n    //% block=\"read Temperature on Pin $pin with Unit $unit\"\n    //% subcategory=\"Sensors\"\n    //% group=\"DHT11\"\n    //% pin.defl=DigitalPin.P0\n    //% unit.defl=celsius\n    export function readTemperature(pin: DigitalPin, unit: tempUnit): number {\n        // Initialize sensor and read data\n        let resultArray: number[] = []\n        let dataArray: boolean[] = []\n        let startTime = input.runningTimeMicros()\n\n        for (let i = 0; i < 40; i++) dataArray.push(false)\n        for (let i = 0; i < 5; i++) resultArray.push(0)\n\n        pins.digitalWritePin(pin, 0)\n        basic.pause(18)\n\n        pins.setPull(pin, PinPullMode.PullUp)\n        pins.digitalReadPin(pin)\n        control.waitMicros(40)\n\n        // Sensor response\n        if (pins.digitalReadPin(pin) == 0) {\n            while (pins.digitalReadPin(pin) == 0);\n            while (pins.digitalReadPin(pin) == 1);\n\n            // Read data\n            for (let i = 0; i < 40; i++) {\n                while (pins.digitalReadPin(pin) == 1);\n                while (pins.digitalReadPin(pin) == 0);\n                control.waitMicros(28)\n                if (pins.digitalReadPin(pin) == 1) dataArray[i] = true\n            }\n\n            // Convert byte data to integer\n            for (let i = 0; i < 5; i++)\n                for (let j = 0; j < 8; j++)\n                    if (dataArray[8 * i + j]) resultArray[i] += 2 ** (7 - j)\n\n            // Temperature and humidity values\n            _humidity = resultArray[0] + resultArray[1] / 100\n            _temperature = resultArray[2] + resultArray[3] / 100\n\n            // Convert to Fahrenheit if needed\n            if (unit == tempUnit.fahrenheit) {\n                _temperature = _temperature * 9 / 5 + 32\n            }\n        }\n\n        return _temperature\n    }\n\n    /**\n    * Read humidity data from DHT11 sensor.\n    * @param pin the pin number where the DHT11 data pin is connected\n    */\n    //% blockId=\"dht11_humidity\"\n    //% block=\"read Humidity on Pin $pin\"\n    //% subcategory=\"Sensors\"\n    //% group=\"DHT11\"\n    //% pin.defl=DigitalPin.P0\n    export function readHumidity(pin: DigitalPin): number {\n        // Initialize sensor and read data\n        let resultArray: number[] = []\n        let dataArray: boolean[] = []\n        let startTime = input.runningTimeMicros()\n\n        for (let i = 0; i < 40; i++) dataArray.push(false)\n        for (let i = 0; i < 5; i++) resultArray.push(0)\n\n        pins.digitalWritePin(pin, 0)\n        basic.pause(18)\n\n        pins.setPull(pin, PinPullMode.PullUp)\n        pins.digitalReadPin(pin)\n        control.waitMicros(40)\n\n        // Sensor response\n        if (pins.digitalReadPin(pin) == 0) {\n            while (pins.digitalReadPin(pin) == 0);\n            while (pins.digitalReadPin(pin) == 1);\n\n            // Read data\n            for (let i = 0; i < 40; i++) {\n                while (pins.digitalReadPin(pin) == 1);\n                while (pins.digitalReadPin(pin) == 0);\n                control.waitMicros(28)\n                if (pins.digitalReadPin(pin) == 1) dataArray[i] = true\n            }\n\n            // Convert byte data to integer\n            for (let i = 0; i < 5; i++)\n                for (let j = 0; j < 8; j++)\n                    if (dataArray[8 * i + j]) resultArray[i] += 2 ** (7 - j)\n\n            // Humidity value\n            _humidity = resultArray[0] + resultArray[1] / 100\n            _temperature = resultArray[2] + resultArray[3] / 100\n        }\n\n        return _humidity\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n\n\n    /**\n     * Get the digital value from the IR sensor (1 for detection, 0 for no detection) on the selected pin.\n     * @param pin the digital pin where the IR sensor is connected\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Sensor\"\n    //% blockId=\"ir_sensor_digital\"\n    //% block=\"ir Sensor on Digital Pin %pin\"\n    //% pin.defl=DigitalPinPrime.P0\n    //% weight=90 blockGap=20\n    export function readIRSensorDigital(pin: DigitalPinPrime): number {\n        // Read the current state of the pin\n        let rawValue = pins.digitalReadPin(pin);\n\n        // Invert the value since 0 means detected and 1 means not detected\n        let invertedValue = rawValue === 0 ? 1 : 0;\n\n        // Reset the pin state (pull back to neutral to avoid latch state)\n        pins.setPull(pin, PinPullMode.PullNone);\n\n        return invertedValue;\n    }\n\n\n\n    /**\n     * Get the analog value from the IR sensor on the selected pin.\n     * @param pin the analog pin where the IR sensor is connected\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Sensor\"\n    //% blockId=\"ir_sensor_analog\"\n    //% block=\"ir Sensor on Analog Pin %pin\"\n    //% pin.defl=AnalogPinPrime.P0\n    //% weight=100 blockGap=20\n    export function readIRSensorAnalog(pin: AnalogPinPrime): number {\n        // Read the value from the specified analog pin\n        const value = pins.analogReadPin(pin);\n        return value; // Return the analog value (0-1023)\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Function to get the digital value of the LDR sensor with reset\n    //% subcategory=\"Sensors\"\n    //% group=\"LDR Sensor\"\n    //% blockId=\"ldr_digital_value_reset\"\n    //% block=\"ldr Sensor on Digital Pin %pin\"\n    //% weight=180 blockGap=20\n    export function getLDRSensorDigitalValueReset(pin: DigitalPinPrime): number {\n        // Ensure the pin is set to input mode before reading\n        pins.setPull(pin, PinPullMode.PullNone);\n\n        // Read the digital value from the pin (either 0 or 1)\n        let value = pins.digitalReadPin(pin);\n\n        // Reset the pin state by reinitializing it as a digital input again\n        pins.setPull(pin, PinPullMode.PullNone); // Reset state by disabling pull-up/down\n\n        // Return the value (0 or 1)\n        return value;\n    }\n\n    // Function to read from an LDR sensor connected to an analog pin\n    //% subcategory=\"Sensors\"\n    //% group=\"LDR Sensor\"\n    //% blockId=\"ldr_analog_value\"\n    //% block=\"ldr Sensor on Analog Pin %pin\"\n    //% weight=180 blockGap=20\n    export function getLDRSensorAnalogValue(pin: AnalogPinPrime): number {\n        // Read and return the inverted analog value (1023 - value)\n        let sensorValue = pins.analogReadPin(pin);\n        return 1023 - sensorValue;  // Invert the value (higher value for dark, lower for light)\n    }\n\n\n\n    /////////////////////////////////////////////////////////////////////////\n\n    // Function to read the moisture sensor value\n    //% subcategory=\"Sensors\"\n    //% group=\"Moisture Sensor\"\n    //% blockId=\"moisture_sensor_value\"\n    //% block=\"moisture sensor value on Pin %pin\"\n    //% weight=180 blockGap=20\n    export function getMoistureSensorValue(pin: AnalogPinPrime): number {\n        // Read and return the analog value from the specified pin\n        return pins.analogReadPin(pin);\n    }\n////////////////////////////////////////////////////////////////////////////\n\n\n\n    const gestureEventId = 3100;\n    let lastGesture = 0;\n\n\n    /* Container for gesture data */\n    export class gesture_data_type {\n        u_data: Buffer;\n        d_data: Buffer;\n        l_data: Buffer;\n        r_data: Buffer;\n        index: number;\n        total_gestures: number;\n        in_threshold: number;\n        out_threshold: number;\n    }\n\n    let gesture_data = new gesture_data_type;\n    let data_buf: Buffer = pins.createBuffer(128);\n\n\n    function APDS9960ReadReg(addr: number): number {\n        let buf: Buffer = pins.createBuffer(1);\n        buf[0] = addr;\n        pins.i2cWriteBuffer(0x39, buf, false);\n        buf = pins.i2cReadBuffer(0x39, 1, false);\n        return buf[0];\n    }\n\n    function APDS9960WriteReg(addr: number, cmd: number) {\n        let buf: Buffer = pins.createBuffer(2);\n\n        buf[0] = addr;\n        buf[1] = cmd;\n\n        pins.i2cWriteBuffer(0x39, buf, false);\n    }\n\n    function readi2c(register: number): number {\n        return pins.i2cReadNumber(register, NumberFormat.UInt8LE);\n    }\n\n    /**\n     * @brief Reads a block (array) of bytes from the I2C device and register\n     *\n     * @param[in] reg the register to read from\n     * @param[out] val pointer to the beginning of the data\n     * @param[in] len number of bytes to read\n     * @return Number of bytes read. -1 on read error.\n     */\n    function APDS9960ReadRegBlock(addr: number, len: number): number {\n        let i: number = 0;\n        let y: number = 0;\n\n        for (let i = 0; i < len; i = i + 4) {\n\n            data_buf[i] = readi2c(0xFc);\n            data_buf[i + 1] = readi2c(0xFd);\n            data_buf[i + 2] = readi2c(0xFe);\n            data_buf[i + 3] = readi2c(0xFf);\n            basic.pause(10);\n            if (DEBUG) {\n                serial.writeLine(data_buf[i].toString() + \" ; \"\n                    + data_buf[i + 1].toString() + \" ; \"\n                    + data_buf[i + 2].toString() + \" ; \"\n                    + data_buf[i + 3].toString() + \" ; \");\n            }\n        }\n\n\n        return len;\n    }\n\n    function getMode(): number {\n        let enable_value: number;\n\n        /* Read current ENABLE register */\n        enable_value = APDS9960ReadReg(APDS9960_ENABLE);\n        return enable_value;\n    }\n\n    function setMode(mode: number, enable: number) {\n        let reg_val: number;\n        /* Read current ENABLE register */\n        reg_val = getMode();\n        /* Change bit(s) in ENABLE register */\n        enable = enable & 0x01;\n        if (mode >= 0 && mode <= 6) {\n            if (enable) {\n                reg_val |= (1 << mode);\n            } else {\n                //reg_val &= ~(1 << mode);\n                reg_val = 0x00;\n            }\n        } else if (mode == ALL) {\n            if (enable) {\n                reg_val = 0x7F;\n            } else {\n                reg_val = 0x00;\n            }\n        }\n\n        /* Write value back to ENABLE register */\n        APDS9960WriteReg(APDS9960_ENABLE, reg_val);\n    }\n\n    /**\n     * @brief Sets the gain of the photodiode during gesture mode\n     *\n     * Value    Gain\n     *   0       1x\n     *   1       2x\n     *   2       4x\n     *   3       8x\n     *\n     * @param[in] gain the value for the photodiode gain\n     * @return True if operation successful. False otherwise.\n     */\n    function setGestureGain(gain: number) {\n        let val: number;\n\n        /* Read value from GCONF2 register */\n        val = APDS9960ReadReg(APDS9960_GCONF2);\n\n        /* Set bits in register to given value */\n        gain &= 0b00000011;\n        gain = gain << 5;\n        val &= 0b10011111;\n        val |= gain;\n\n        /* Write register value back into GCONF2 register */\n        APDS9960WriteReg(APDS9960_GCONF2, val);\n    }\n\n    /**\n     * @brief Sets the LED drive current during gesture mode\n     *\n     * Value    LED Current\n     *   0        100 mA\n     *   1         50 mA\n     *   2         25 mA\n     *   3         12.5 mA\n     *\n     * @param[in] drive the value for the LED drive current\n     * @return True if operation successful. False otherwise.\n     */\n    function setGestureLEDDrive(drive: number) {\n        let val: number;\n\n        /* Read value from GCONF2 register */\n        val = APDS9960ReadReg(APDS9960_GCONF2);\n\n        /* Set bits in register to given value */\n        drive &= 0b00000011;\n        drive = drive << 3;\n        val &= 0b11100111;\n        val |= drive;\n\n        /* Write register value back into GCONF2 register */\n        APDS9960WriteReg(APDS9960_GCONF2, val);\n    }\n\n    /**\n     * @brief Sets the LED current boost value\n     *\n     * Value  Boost Current\n     *   0        100%\n     *   1        150%\n     *   2        200%\n     *   3        300%\n     *\n     * @param[in] drive the value (0-3) for current boost (100-300%)\n     * @return True if operation successful. False otherwise.\n     */\n    function setLEDBoost(boost: number) {\n        let val: number;\n\n        /* Read value from CONFIG2 register */\n        val = APDS9960ReadReg(APDS9960_CONFIG2);\n\n        /* Set bits in register to given value */\n        boost &= 0b00000011;\n        boost = boost << 4;\n        val &= 0b11001111;\n        val |= boost;\n\n        /* Write register value back into CONFIG2 register */\n        APDS9960WriteReg(APDS9960_CONFIG2, val);\n    }\n\n    /**\n     * @brief Sets the time in low power mode between gesture detections\n     *\n     * Value    Wait time\n     *   0          0 ms\n     *   1          2.8 ms\n     *   2          5.6 ms\n     *   3          8.4 ms\n     *   4         14.0 ms\n     *   5         22.4 ms\n     *   6         30.8 ms\n     *   7         39.2 ms\n     *\n     * @param[in] the value for the wait time\n     * @return True if operation successful. False otherwise.\n     */\n    function setGestureWaitTime(time: number) {\n        let val: number;\n\n        /* Read value from GCONF2 register */\n        val = APDS9960ReadReg(APDS9960_GCONF2);\n\n        /* Set bits in register to given value */\n        time &= 0b00000111;\n        val &= 0b11111000;\n        val |= time;\n\n        /* Write register value back into GCONF2 register */\n        APDS9960WriteReg(APDS9960_GCONF2, val);\n    }\n\n    /**\n     * @brief Turns gesture-related interrupts on or off\n     *\n     * @param[in] enable 1 to enable interrupts, 0 to turn them off\n     * @return True if operation successful. False otherwise.\n     */\n    function setGestureIntEnable(enable: number) {\n        let val: number;\n\n        /* Read value from GCONF4 register */\n        val = APDS9960ReadReg(APDS9960_GCONF4);\n\n        /* Set bits in register to given value */\n        enable &= 0b00000001;\n        enable = enable << 1;\n        val &= 0b11111101;\n        val |= enable;\n\n        /* Write register value back into GCONF4 register */\n        APDS9960WriteReg(APDS9960_GCONF4, val);\n    }\n\n    /**\n     * @brief Resets all the parameters in the gesture data member\n     */\n    function resetGestureParameters() {\n        gesture_data.index = 0;\n        gesture_data.total_gestures = 0;\n\n        gesture_ud_delta = 0;\n        gesture_lr_delta = 0;\n\n        gesture_ud_count = 0;\n        gesture_lr_count = 0;\n\n        gesture_near_count = 0;\n        gesture_far_count = 0;\n\n        gesture_state = 0;\n        gesture_motion = DIR.DIR_NONE;\n    }\n\n    /**\n     * @brief Tells the state machine to either enter or exit gesture state machine\n     *\n     * @param[in] mode 1 to enter gesture state machine, 0 to exit.\n     * @return True if operation successful. False otherwise.\n     */\n    function setGestureMode(mode: number) {\n        let val: number;\n\n        /* Read value from GCONF4 register */\n        val = APDS9960ReadReg(APDS9960_GCONF4);\n\n        /* Set bits in register to given value */\n        mode &= 0b00000001;\n        val &= 0b11111110;\n        val |= mode;\n\n        /* Write register value back into GCONF4 register */\n        APDS9960WriteReg(APDS9960_GCONF4, val);\n    }\n\n    /**\n     * Turn the APDS-9960 on\n     *\n     * @return True if operation successful. False otherwise.\n     */\n    function enablePower() {\n        setMode(POWER, 1);\n    }\n\n    /**\n     * @brief Starts the gesture recognition engine on the APDS-9960\n     *\n     * @param[in] interrupts true to enable hardware external interrupt on gesture\n     * @return True if engine enabled correctly. False on error.\n     */\n    function enableGestureSensor(interrupts: boolean) {\n        /* Enable gesture mode\n        Set ENABLE to 0 (power off)\n        Set WTIME to 0xFF\n        Set AUX to LED_BOOST_300\n        Enable PON, WEN, PEN, GEN in ENABLE \n        */\n        resetGestureParameters();\n        APDS9960WriteReg(APDS9960_WTIME, 0xFF);\n        APDS9960WriteReg(APDS9960_PPULSE, DEFAULT_GESTURE_PPULSE);\n        setLEDBoost(LED_BOOST_300);\n        if (interrupts) {\n            setGestureIntEnable(1);\n        } else {\n            setGestureIntEnable(0);\n        }\n        setGestureMode(1);\n        enablePower();\n        setMode(WAIT, 1)\n        setMode(PROXIMITY, 1);\n        setMode(GESTURE, 1);\n    }\n\n    function pads9960_init() {\n        let aa = APDS9960ReadReg(0X92);\n        if (aa == 0xAB) {\n            APDS9960WriteReg(APDS9960_GPENTH, DEFAULT_GPENTH);//0x28\n            APDS9960WriteReg(APDS9960_GEXTH, DEFAULT_GEXTH);//0x1e\n            APDS9960WriteReg(APDS9960_GCONF1, DEFAULT_GCONF1);//0x40\n            setGestureGain(DEFAULT_GGAIN);//0x41\n            setGestureLEDDrive(DEFAULT_GLDRIVE);\n            setGestureWaitTime(DEFAULT_GWTIME);\n            APDS9960WriteReg(APDS9960_GOFFSET_U, DEFAULT_GOFFSET);\n            APDS9960WriteReg(APDS9960_GOFFSET_D, DEFAULT_GOFFSET);\n            APDS9960WriteReg(APDS9960_GOFFSET_L, DEFAULT_GOFFSET);\n            APDS9960WriteReg(APDS9960_GOFFSET_R, DEFAULT_GOFFSET);\n            APDS9960WriteReg(APDS9960_GPULSE, DEFAULT_GPULSE);//0xc9\n            APDS9960WriteReg(APDS9960_GCONF3, DEFAULT_GCONF3);//00\n            setGestureIntEnable(DEFAULT_GIEN);\n        }\n\n        if (0) {\n            /* Gesture config register dump */\n            let reg: number = 0x00;\n            let val: number = 0x00;\n\n            for (reg = 0x80; reg <= 0xAF; reg++) {\n                if ((reg != 0x82) &&\n                    (reg != 0x8A) &&\n                    (reg != 0x91) &&\n                    (reg != 0xA8) &&\n                    (reg != 0xAC) &&\n                    (reg != 0xAD)) {\n                    val = APDS9960ReadReg(reg);\n                    serial.writeLine(reg + \": 0x\" + val);\n                }\n            }\n\n            for (reg = 0xE4; reg <= 0xE7; reg++) {\n                val = APDS9960ReadReg(reg);\n                serial.writeLine(reg + \": 0x\" + val);\n            }\n\n        }\n        // serial.writeLine(\"init sensor finish\");\n    }\n\n    /**\n     * @brief Determines if there is a gesture available for reading\n     *\n     * @return True if gesture available. False otherwise.\n     */\n    function isGestureAvailable(): boolean {\n        let val: number;\n\n        /* Read value from GSTATUS register */\n        val = APDS9960ReadReg(APDS9960_GSTATUS);\n        /* Shift and mask out GVALID bit */\n        val &= APDS9960_GVALID;\n\n        /* Return true/false based on GVALID bit */\n        if (val == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @brief Processes the raw gesture data to determine swipe direction\n     *\n     * @return True if near or far state seen. False otherwise.\n     */\n    function processGestureData(): boolean {\n        let u_first: number = 0;\n        let d_first: number = 0;\n        let l_first: number = 0;\n        let r_first: number = 0;\n        let u_last: number = 0;\n        let d_last: number = 0;\n        let l_last: number = 0;\n        let r_last: number = 0;\n        let ud_ratio_first: number;\n        let lr_ratio_first: number;\n        let ud_ratio_last: number;\n        let lr_ratio_last: number;\n        let ud_delta: number;\n        let lr_delta: number;\n        let i: number;\n\n        /* If we have less than 4 total gestures, that's not enough */\n        if (gesture_data.total_gestures <= 4) {\n            return false;\n        }\n\n        /* Check to make sure our data isn't out of bounds */\n        if ((gesture_data.total_gestures <= 32) && (gesture_data.total_gestures > 0)) {\n\n            /* Find the first value in U/D/L/R above the threshold */\n            for (i = 0; i < gesture_data.total_gestures; i++) {\n                if ((gesture_data.u_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.d_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.l_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.r_data[i] > GESTURE_THRESHOLD_OUT)) {\n\n                    u_first = gesture_data.u_data[i];\n                    d_first = gesture_data.d_data[i];\n                    l_first = gesture_data.l_data[i];\n                    r_first = gesture_data.r_data[i];\n                    break;\n                }\n            }\n\n            /* If one of the _first values is 0, then there is no good data */\n            if ((u_first == 0) || (d_first == 0) || (l_first == 0) || (r_first == 0)) {\n\n                return false;\n            }\n            /* Find the last value in U/D/L/R above the threshold */\n            for (i = gesture_data.total_gestures - 1; i >= 0; i--) {\n\n\n                if ((gesture_data.u_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.d_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.l_data[i] > GESTURE_THRESHOLD_OUT) &&\n                    (gesture_data.r_data[i] > GESTURE_THRESHOLD_OUT)) {\n\n                    u_last = gesture_data.u_data[i];\n                    d_last = gesture_data.d_data[i];\n                    l_last = gesture_data.l_data[i];\n                    r_last = gesture_data.r_data[i];\n                    break;\n                }\n            }\n        }\n\n        /* Calculate the first vs. last ratio of up/down and left/right */\n        ud_ratio_first = ((u_first - d_first) * 100) / (u_first + d_first);\n        lr_ratio_first = ((l_first - r_first) * 100) / (l_first + r_first);\n        ud_ratio_last = ((u_last - d_last) * 100) / (u_last + d_last);\n        lr_ratio_last = ((l_last - r_last) * 100) / (l_last + r_last);\n        if (ud_ratio_first == 0 && lr_ratio_first == 0 && ud_ratio_last == 0 && lr_ratio_last == 0) {\n\n            //pads9960_init();\n            // enableGestureSensor(false);\n        }\n        if (DEBUG) {\n            serial.writeLine(\"first Values: \" + \"U:\" + u_first\n                + \" D:\" + d_first\n                + \" L:\" + l_first\n                + \" R:\" + r_first);\n            serial.writeLine(\"Last Values: \" + \"U:\" + u_last\n                + \" D:\" + d_last\n                + \" L:\" + l_last\n                + \" R:\" + r_last);\n            serial.writeLine(\"Ratios: \" + \"UD Fi:\" + ud_ratio_first\n                + \" UD La:\" + ud_ratio_last\n                + \" LR Fi:\" + lr_ratio_first\n                + \" LR La:\" + lr_ratio_last);\n\n        }\n\n        /* Determine the difference between the first and last ratios */\n        ud_delta = ud_ratio_last - ud_ratio_first;\n        lr_delta = lr_ratio_last - lr_ratio_first;\n        if (DEBUG) {\n            serial.writeLine(\"Deltas: \" + \"UD: \" + ud_delta + \" LR: \" + lr_delta);\n        }\n\n        /* Accumulate the UD and LR delta values */\n        gesture_ud_delta += ud_delta;\n        gesture_lr_delta += lr_delta;\n        if (DEBUG) {\n            serial.writeLine(\"Accumulations: \" + \"UD: \" + gesture_ud_delta + \" LR: \" + gesture_lr_delta);\n        }\n        /* Determine U/D gesture */\n        if (gesture_ud_delta >= GESTURE_SENSITIVITY_1) {\n            gesture_ud_count = 1;\n        } else if (gesture_ud_delta <= -GESTURE_SENSITIVITY_1) {\n            gesture_ud_count = -1;\n        } else {\n            gesture_ud_count = 0;\n        }\n\n        /* Determine L/R gesture */\n        if (gesture_lr_delta >= GESTURE_SENSITIVITY_1) {\n            gesture_lr_count = 1;\n        } else if (gesture_lr_delta <= -GESTURE_SENSITIVITY_1) {\n            gesture_lr_count = -1;\n        } else {\n            gesture_lr_count = 0;\n        }\n\n        /* Determine Near/Far gesture */\n        if ((gesture_ud_count == 0) && (gesture_lr_count == 0)) {\n            if ((Math.abs(ud_delta) < GESTURE_SENSITIVITY_2) && (Math.abs(lr_delta) < GESTURE_SENSITIVITY_2)) {\n\n                if ((ud_delta == 0) && (lr_delta == 0)) {\n                    gesture_near_count++;\n                } else if ((ud_delta != 0) || (lr_delta != 0)) {\n                    gesture_far_count++;\n                }\n\n                if ((gesture_near_count >= 10) && (gesture_far_count >= 2)) {\n                    if ((ud_delta == 0) && (lr_delta == 0)) {\n                        gesture_state = STATE.NEAR_STATE;\n                    } else if ((ud_delta != 0) && (lr_delta != 0)) {\n                        gesture_state = STATE.FAR_STATE;\n                    }\n                    return true;\n                }\n            }\n        } else {\n            if ((Math.abs(ud_delta) < GESTURE_SENSITIVITY_2) && (Math.abs(lr_delta) < GESTURE_SENSITIVITY_2)) {\n\n                if ((ud_delta == 0) && (lr_delta == 0)) {\n                    gesture_near_count++;\n                }\n\n                if (gesture_near_count >= 10) {\n                    gesture_ud_count = 0;\n                    gesture_lr_count = 0;\n                    gesture_ud_delta = 0;\n                    gesture_lr_delta = 0;\n                }\n            }\n        }\n\n        if (DEBUG) {\n            serial.writeLine(\"UD_CT: \" + gesture_ud_count + \" LR_CT: \" + gesture_lr_count + \" NEAR_CT: \" + gesture_near_count\n                + \" FAR_CT: \" + gesture_far_count);\n        }\n\n        return true;\n    }\n\n    /**\n     * @brief Determines swipe direction or near/far state\n     *\n     * @return True if near/far event. False otherwise.\n     */\n    function decodeGesture(): boolean {\n        //(\"gesture_state\"+gesture_state);\n        // serial.writeLine(\"gesture_ud_count: \"+gesture_ud_count+\" ; \"+\"gesture_lr_count: \"+gesture_lr_count);\n        /* Return if near or far event is detected */\n        if (gesture_state == STATE.NEAR_STATE) {\n            gesture_motion = DIR.DIR_NEAR;\n            return true;\n        } else if (gesture_state == STATE.FAR_STATE) {\n            gesture_motion = DIR.DIR_FAR;\n            return true;\n        }\n\n        /* Determine swipe direction */\n        if ((gesture_ud_count == -1) && (gesture_lr_count == 0)) {\n            gesture_motion = DIR.DIR_UP;\n        } else if ((gesture_ud_count == 1) && (gesture_lr_count == 0)) {\n            gesture_motion = DIR.DIR_DOWN;\n        } else if ((gesture_ud_count == 0) && (gesture_lr_count == 1)) {\n            gesture_motion = DIR.DIR_RIGHT;\n        } else if ((gesture_ud_count == 0) && (gesture_lr_count == -1)) {\n            gesture_motion = DIR.DIR_LEFT;\n        } else if ((gesture_ud_count == -1) && (gesture_lr_count == 1)) {\n            if (Math.abs(gesture_ud_delta) > Math.abs(gesture_lr_delta)) {\n                gesture_motion = DIR.DIR_UP;\n            } else {\n                gesture_motion = DIR.DIR_RIGHT;\n            }\n        } else if ((gesture_ud_count == 1) && (gesture_lr_count == -1)) {\n            if (Math.abs(gesture_ud_delta) > Math.abs(gesture_lr_delta)) {\n                gesture_motion = DIR.DIR_DOWN;\n            } else {\n                gesture_motion = DIR.DIR_LEFT;\n            }\n        } else if ((gesture_ud_count == -1) && (gesture_lr_count == -1)) {\n            if (Math.abs(gesture_ud_delta) > Math.abs(gesture_lr_delta)) {\n                gesture_motion = DIR.DIR_UP;\n            } else {\n                gesture_motion = DIR.DIR_LEFT;\n            }\n        } else if ((gesture_ud_count == 1) && (gesture_lr_count == 1)) {\n            if (Math.abs(gesture_ud_delta) > Math.abs(gesture_lr_delta)) {\n                gesture_motion = DIR.DIR_DOWN;\n            } else {\n                gesture_motion = DIR.DIR_RIGHT;\n            }\n        } else {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @brief Processes a gesture event and returns best guessed gesture\n     *\n     * @return Number corresponding to gesture. -1 on error.\n     */\n    function readGesture(): number {\n        let fifo_level: number = 0;\n        let bytes_read: number = 0;\n        let fifo_data: number[] = [];\n        let gstatus: number;\n        let motion: number;\n        let i: number;\n        //resetGestureParameters();\n        gesture_data.d_data = pins.createBuffer(32);\n        gesture_data.u_data = pins.createBuffer(32);\n        gesture_data.l_data = pins.createBuffer(32);\n        gesture_data.r_data = pins.createBuffer(32);\n        //(\"read sensor start\");\n        /* Make sure that power and gesture is on and data is valid */\n        if (!isGestureAvailable() || !(getMode() & 0b01000001)) {\n            return DIR.DIR_NONE;\n        }\n\n        /* Keep looping as long as gesture data is valid */\n        while (1) {\n            basic.pause(30);\n            /* Get the contents of the STATUS register. Is data still valid? */\n            gstatus = APDS9960ReadReg(APDS9960_GSTATUS);\n            /* If we have valid data, read in FIFO */\n            if ((gstatus & APDS9960_GVALID) == APDS9960_GVALID) {\n                /* Read the current FIFO level */\n                fifo_level = APDS9960ReadReg(APDS9960_GFLVL);\n\n                if (DEBUG) {\n                    serial.writeLine(\"FIFO Level: \" + fifo_level);\n                }\n\n                /* If there's stuff in the FIFO, read it into our data block */\n                if (fifo_level > 0) {\n                    bytes_read = APDS9960ReadRegBlock(APDS9960_GFIFO_U,\n                        (fifo_level * 4));\n                    // bytes_read = APDS9960ReadRegBlock(APDS9960_GFIFO_U,fifo_level );\n\n                    for (let i = 0; i < bytes_read; i++) {\n                        fifo_data[i] = data_buf[i];\n                    }\n\n                    if (0) {\n                        serial.writeLine(\"FIFO Dump: \");\n                        for (i = 0; i < bytes_read; i++) {\n                            serial.writeLine(\"NO. \" + i + \" : \" + fifo_data[i]);\n                        }\n                        serial.writeLine(\"FIFO END\");\n                    }\n\n                    if (bytes_read >= 4) {\n                        for (let ii = 0; ii < bytes_read; ii = ii + 4) {\n                            gesture_data.u_data[gesture_data.index] = fifo_data[ii + 0];\n                            gesture_data.d_data[gesture_data.index] = fifo_data[ii + 1];\n                            gesture_data.l_data[gesture_data.index] = fifo_data[ii + 2];\n                            gesture_data.r_data[gesture_data.index] = fifo_data[ii + 3];\n                            gesture_data.index++;\n                            gesture_data.total_gestures++;\n                        }\n\n                        if (0) {\n                            serial.writeLine(\"Up Data: \");\n                            for (i = 0; i < gesture_data.total_gestures; i++) {\n                                serial.writeLine(gesture_data.u_data[i].toString());\n                            }\n                            serial.writeLine(\"Up END\");\n                        }\n\n                        /* Filter and process gesture data. Decode near/far state */\n                        if (processGestureData()) {\n                            if (decodeGesture()) {\n                                motion = gesture_motion;\n                                if (DEBUG) {\n                                    serial.writeLine(\"gesture_motion: \" + gesture_motion.toString());\n                                }\n                                resetGestureParameters();\n                                return motion;\n                            }\n                        }\n                        /* Reset data */\n                        gesture_data.index = 0;\n                        gesture_data.total_gestures = 0;\n                    }\n\n                }\n\n            }\n            else {\n                /* Determine best guessed gesture and clean up */\n                basic.pause(30);\n                decodeGesture();\n                motion = gesture_motion;\n                if (DEBUG) {\n                    serial.writeLine(\"END: \");\n                    serial.writeLine(\"gesture_motion\" + gesture_motion);\n                }\n\n                resetGestureParameters();\n                return motion;\n            }\n\n        }\n\n        motion = gesture_motion;\n        return motion;\n    }\n\n    /**\n     * Create a new driver of Grove - Gesture\n     */\n    //% blockId=grove_gesture_init\n    //% block=\"%apds9960|Initiate the Gesture sensor APDS9960\"\n    //% subcategory=\"gesture apds9960\"\n    export function init() {\n        pads9960_init();\n        enableGestureSensor(false);\n        //serial.writeLine(\"Initializing\");\n        if (0) {\n            /* Gesture config register dump */\n            let reg: number = 0x00;\n            let val: number = 0x00;\n\n            for (reg = 0x80; reg <= 0xAF; reg++) {\n                if ((reg != 0x82) &&\n                    (reg != 0x8A) &&\n                    (reg != 0x91) &&\n                    (reg != 0xA8) &&\n                    (reg != 0xAC) &&\n                    (reg != 0xAD)) {\n                    val = APDS9960ReadReg(reg);\n                    //serial.writeLine(reg + \": 0x\" + val);\n                }\n            }\n\n            for (reg = 0xE4; reg <= 0xE7; reg++) {\n                val = APDS9960ReadReg(reg);\n                //serial.writeLine(reg + \": 0x\" + val);\n            }\n\n        }\n    }\n\n    /**\n     * Do something when a gesture is detected by Grove - Gesture\n     * @param gesture type of gesture to detect\n     * @param handler code to run\n     */\n    //% blockId=grove_gesture_create_event\n    //% block=\"Gesture|%gesture\"\n    //% subcategory=\"gesture apds9960\"\n    //export function onGesture(gesture: BrickcellGesture, handler: Action) {\n    export function onGesture(gesture: BrickcellGesture, body: () => void): void {\n        //control.onEvent(gestureEventId, gesture, handler);\n        //let apds9960 = new APDS9960();\n        //init();\n        if (gesture == BrickcellGesture.Right) control.onEvent(gestureRightID, gesture, body);\n        if (gesture == BrickcellGesture.Left) control.onEvent(gestureLeftID, gesture, body);\n        if (gesture == BrickcellGesture.Up) control.onEvent(gestureUpID, gesture, body);\n        if (gesture == BrickcellGesture.Down) control.onEvent(gestureDownID, gesture, body);\n\n        control.inBackground(() => {\n            while (true) {\n                const gesture = readGesture();\n\n                if (gesture != lastGesture) {\n                    lastGesture = gesture;\n                    switch (gesture) {\n                        case 1:\n                            control.raiseEvent(gestureRightID, BrickcellGesture.Right);\n                            break;\n                        case 2:\n                            control.raiseEvent(gestureLeftID, BrickcellGesture.Left);\n                            break;\n                        case 3:\n                            control.raiseEvent(gestureUpID, BrickcellGesture.Up);\n                            break;\n                        case 4:\n                            control.raiseEvent(gestureDownID, BrickcellGesture.Down);\n                            break;\n                    }\n                }\n                //basic.pause(1800);\n                basic.pause(50);\n                //serial.writeLine(\"Start gesture.\");\n            }\n        })\n    }\n\n\n    /////////////////////////////////////////////////////////////////////////\n    ////////////////////\n    //Actuators //\n    ////////////////////\n\n\n    // Convert any DigitalPinPrime to AnalogPin (for PWM control)\n    function getDigitalPin(pin: DigitalPinPrime): DigitalPin {\n        switch (pin) {\n            case DigitalPinPrime.P0: return DigitalPin.P0;\n            case DigitalPinPrime.P1: return DigitalPin.P1;\n            case DigitalPinPrime.P2: return DigitalPin.P2;\n            case DigitalPinPrime.P3: return DigitalPin.P3;\n            case DigitalPinPrime.P4: return DigitalPin.P4;\n            case DigitalPinPrime.P9: return DigitalPin.P9;\n            case DigitalPinPrime.P10: return DigitalPin.P10;\n            case DigitalPinPrime.P13: return DigitalPin.P13;\n            case DigitalPinPrime.P14: return DigitalPin.P14;\n            case DigitalPinPrime.P15: return DigitalPin.P15;\n            case DigitalPinPrime.P19: return DigitalPin.P19;\n            case DigitalPinPrime.P20: return DigitalPin.P20;\n            default: return DigitalPin.P0; // Fallback\n        }\n    }\n\n    // Define servo positions enumeration\n    export enum ServoPosition {\n        //% block=\"0 degrees\"\n        Zero = 0,\n        //% block=\"45 degrees\"\n        FortyFive = 45,\n        //% block=\"90 degrees\"\n        Ninety = 90,\n        //% block=\"135 degrees\"\n        OneThirtyFive = 135,\n        //% block=\"180 degrees\"\n        OneEighty = 180\n    }\n\n\n    /**\n    * Moves a servo to a specified position.\n    * @param pin which pin to control\n    * @param position the position to move to\n    */\n    //% subcategory=\"Actuators\"\n    //% weight=150 blockGap=8\n    //% group=\"Positional Servo\"\n    //% blockId=\"move_positional_servo\"\n    //% block=\"move servo on pin %pin|to position %position\"\n    //% position.min=0 position.max=180\n    export function movePositionalServo(pin: DigitalPinPrime, position: number): void {\n        const angle = Math.clamp(0, 180, position);  // Ensure angle is within 0-180 range\n        pins.servoWritePin(getDigitalPin(pin), angle);\n    }\n\n    /**\n     * Moves a servo to a specified position.\n     * @param pin which pin to control\n     * @param position the position to move to\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=120 blockGap=8\n    //% group=\"Positional Servo\"\n    //% blockId=\"move_positional_servo_to_fixed_point\"\n    //% block=\"move servo on pin %pin|to position %position\"\n    export function movePositionalServofixed(pin: DigitalPinPrime, position: ServoPosition): void {\n        // Using the ServoPosition enum, which already contains the angle values\n        pins.servoWritePin(getDigitalPin(pin), position);  // position is directly the angle in degrees\n    }\n\n    //% subcategory=\"Actuators\"\n    //% weight=10 blockGap=8\n    //% group=\"Positional Servo\" \n    //% blockId=\"move_servo_from_to\"\n    //% block=\"move servo on pin %pin|from angle %from|to angle %to|over %duration seconds\"\n    //% from.min=0 from.max=180\n    //% to.min=0 to.max=180\n    //% duration.min=1 duration.max=10\n    export function moveServoFromTo1(pin: DigitalPinPrime, from: number, to: number, duration: number): void {\n        const startAngle = Math.clamp(0, 180, from);\n        const endAngle = Math.clamp(0, 180, to);\n        const steps = Math.abs(endAngle - startAngle);\n        const stepDuration = duration * 1000 / steps;\n\n        // Loop through each step and move the servo\n        for (let i = 0; i <= steps; i++) {\n            // Calculate the current angle for the servo based on the direction of movement\n            const currentAngle = startAngle + (endAngle > startAngle ? i : -i);\n\n            // Ensure that we don't exceed the target angle, especially when rounding\n            if ((endAngle > startAngle && currentAngle >= endAngle) || (endAngle < startAngle && currentAngle <= endAngle)) {\n                // Set the final angle to the target and break the loop\n                pins.servoWritePin(getDigitalPin(pin), endAngle);\n                break; // exit the loop once we reach the target angle\n            } else {\n                // Otherwise, move the servo to the current calculated angle\n                pins.servoWritePin(getDigitalPin(pin), currentAngle);\n            }\n\n            // Pause for the time before moving to the next step\n            basic.pause(stepDuration);\n        }\n    }\n\n    /**\n     * Controls the speed and direction of a continuous rotation servo.\n     * @param pin which pin to control\n     * @param speed the speed of the servo motor (-100 to 100)\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=40 blockGap=8\n    //% group=\"Continuous Servo\"\n    //% blockId=\"move_continuous_servo\"\n    //% block=\"set continuous servo on pin %pin|to speed %speed\"\n    //% speed.min=-100 speed.max=100\n    export function moveContinuousServo(pin: DigitalPinPrime, speed: number): void {\n        const speedValue = Math.clamp(-100, 100, speed);  // Ensure speed is within -100 to 100 range\n\n        // Map speed to the correct PWM values (using -100 for full reverse and 100 for full forward)\n        const pwmValue = Math.map(speedValue, -100, 100, 0, 180);  // 40-120 range typically works for continuous servos\n\n        // Write the PWM value to the pin\n        pins.servoWritePin(getDigitalPin(pin), pwmValue);\n    }\n\n\n    /**\n     * Stops the continuous rotation servo.\n     * @param pin which pin to control\n     */\n    //% subcategory=\"Actuators\"\n    //% weight=30 blockGap=8\n    //% group=\"Continuous Servo\"\n    //% blockId=\"stop_continuous_servo\"\n    //% block=\"stop continuous servo on pin %pin\"\n    export function stopContinuousServo(pin: DigitalPinPrime): void {\n        // Set speed to 0 to stop the motor\n        pins.servoWritePin(getDigitalPin(pin), 90);  // 90 typically stops a continuous servo\n    }\n\n\n    /////////////////////////////////////////////////////////////////////////\n\n\n    declare interface Math {\n        floor(x: number): number;\n    }\n    let font: Buffer;\n    const SSD1306_SETCONTRAST = 0x81\n    const SSD1306_SETCOLUMNADRESS = 0x21\n    const SSD1306_SETPAGEADRESS = 0x22\n    const SSD1306_DISPLAYALLON_RESUME = 0xA4\n    const SSD1306_DISPLAYALLON = 0xA5\n    const SSD1306_NORMALDISPLAY = 0xA6\n    const SSD1306_INVERTDISPLAY = 0xA7\n    const SSD1306_DISPLAYOFF = 0xAE\n    const SSD1306_DISPLAYON = 0xAF\n    const SSD1306_SETDISPLAYOFFSET = 0xD3\n    const SSD1306_SETCOMPINS = 0xDA\n    const SSD1306_SETVCOMDETECT = 0xDB\n    const SSD1306_SETDISPLAYCLOCKDIV = 0xD5\n    const SSD1306_SETPRECHARGE = 0xD9\n    const SSD1306_SETMULTIPLEX = 0xA8\n    const SSD1306_SETLOWCOLUMN = 0x00\n    const SSD1306_SETHIGHCOLUMN = 0x10\n    const SSD1306_SETSTARTLINE = 0x40\n    const SSD1306_MEMORYMODE = 0x20\n    const SSD1306_COMSCANINC = 0xC0\n    const SSD1306_COMSCANDEC = 0xC8\n    const SSD1306_SEGREMAP = 0xA0\n    const SSD1306_CHARGEPUMP = 0x8D\n    const chipAdress = 0x3C\n    const xOffset = 0\n    const yOffset = 0\n    let charX = 0\n    let charY = 0\n    let displayWidth = 128\n    let displayHeight = 64 / 8\n    let screenSize = 0\n\n    //let font: Array<Array<number>>\n    let loadStarted: boolean;\n    let loadPercent: number;\n    function command(cmd: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = 0x00\n        buf[1] = cmd\n        pins.i2cWriteBuffer(chipAdress, buf, false)\n    }\n\n\n    //% subcategory=\"Actuators\"\n    //% group=\"OLED\"\n    //% block=\"initialize OLED with width $width height $height\"\n    //% width.defl=128\n    //% height.defl=64\n    //% weight=150\n    export function initOLED(width: number, height: number) {\n        command(SSD1306_DISPLAYOFF);\n        command(SSD1306_SETDISPLAYCLOCKDIV);\n        command(0x80);                                  // the suggested ratio 0x80\n        command(SSD1306_SETMULTIPLEX);\n        command(0x3F);\n        command(SSD1306_SETDISPLAYOFFSET);\n        command(0x0);                                   // no offset\n        command(SSD1306_SETSTARTLINE | 0x0);            // line #0\n        command(SSD1306_CHARGEPUMP);\n        command(0x14);\n        command(SSD1306_MEMORYMODE);\n        command(0x00);                                  // 0x0 act like ks0108\n        command(SSD1306_SEGREMAP | 0x1);\n        command(SSD1306_COMSCANDEC);\n        command(SSD1306_SETCOMPINS);\n        command(0x12);\n        command(SSD1306_SETCONTRAST);\n        command(0xCF);\n        command(SSD1306_SETPRECHARGE);\n        command(0xF1);\n        command(SSD1306_SETVCOMDETECT);\n        command(0x40);\n        command(SSD1306_DISPLAYALLON_RESUME);\n        command(SSD1306_NORMALDISPLAY);\n        command(SSD1306_DISPLAYON);\n        displayWidth = width\n        displayHeight = height / 8\n        screenSize = displayWidth * displayHeight\n        charX = xOffset\n        charY = yOffset\n        font = hex`\n    0000000000\n    3E5B4F5B3E\n    3E6B4F6B3E\n    1C3E7C3E1C\n    183C7E3C18\n    1C577D571C\n    1C5E7F5E1C\n    00183C1800\n    FFE7C3E7FF\n    0018241800\n    FFE7DBE7FF\n    30483A060E\n    2629792926\n    407F050507\n    407F05253F\n    5A3CE73C5A\n    7F3E1C1C08\n    081C1C3E7F\n    14227F2214\n    5F5F005F5F\n    06097F017F\n    006689956A\n    6060606060\n    94A2FFA294\n    08047E0408\n    10207E2010\n    08082A1C08\n    081C2A0808\n    1E10101010\n    0C1E0C1E0C\n    30383E3830\n    060E3E0E06\n    0000000000\n    00005F0000\n    0007000700\n    147F147F14\n    242A7F2A12\n    2313086462\n    3649562050\n    0008070300\n    001C224100\n    0041221C00\n    2A1C7F1C2A\n    08083E0808\n    0080703000\n    0808080808\n    0000606000\n    2010080402\n    3E5149453E\n    00427F4000\n    7249494946\n    2141494D33\n    1814127F10\n    2745454539\n    3C4A494931\n    4121110907\n    3649494936\n    464949291E\n    0000140000\n    0040340000\n    0008142241\n    1414141414\n    0041221408\n    0201590906\n    3E415D594E\n    7C1211127C\n    7F49494936\n    3E41414122\n    7F4141413E\n    7F49494941\n    7F09090901\n    3E41415173\n    7F0808087F\n    00417F4100\n    2040413F01\n    7F08142241\n    7F40404040\n    7F021C027F\n    7F0408107F\n    3E4141413E\n    7F09090906\n    3E4151215E\n    7F09192946\n    2649494932\n    03017F0103\n    3F4040403F\n    1F2040201F\n    3F4038403F\n    6314081463\n    0304780403\n    6159494D43\n    007F414141\n    0204081020\n    004141417F\n    0402010204\n    4040404040\n    0003070800\n    2054547840\n    7F28444438\n    3844444428\n    384444287F\n    3854545418\n    00087E0902\n    18A4A49C78\n    7F08040478\n    00447D4000\n    2040403D00\n    7F10284400\n    00417F4000\n    7C04780478\n    7C08040478\n    3844444438\n    FC18242418\n    18242418FC\n    7C08040408\n    4854545424\n    04043F4424\n    3C4040207C\n    1C2040201C\n    3C4030403C\n    4428102844\n    4C9090907C\n    4464544C44\n    0008364100\n    0000770000\n    0041360800\n    0201020402\n    3C2623263C\n    1EA1A16112\n    3A4040207A\n    3854545559\n    2155557941\n    2154547841\n    2155547840\n    2054557940\n    0C1E527212\n    3955555559\n    3954545459\n    3955545458\n    0000457C41\n    0002457D42\n    0001457C40\n    F0292429F0\n    F0282528F0\n    7C54554500\n    2054547C54\n    7C0A097F49\n    3249494932\n    3248484832\n    324A484830\n    3A4141217A\n    3A42402078\n    009DA0A07D\n    3944444439\n    3D4040403D\n    3C24FF2424\n    487E494366\n    2B2FFC2F2B\n    FF0929F620\n    C0887E0903\n    2054547941\n    0000447D41\n    3048484A32\n    384040227A\n    007A0A0A72\n    7D0D19317D\n    2629292F28\n    2629292926\n    30484D4020\n    3808080808\n    0808080838\n    2F10C8ACBA\n    2F102834FA\n    00007B0000\n    08142A1422\n    22142A1408\n    AA005500AA\n    AA55AA55AA\n    000000FF00\n    101010FF00\n    141414FF00\n    1010FF00FF\n    1010F010F0\n    141414FC00\n    1414F700FF\n    0000FF00FF\n    1414F404FC\n    141417101F\n    10101F101F\n    1414141F00\n    101010F000\n    0000001F10\n    1010101F10\n    101010F010\n    000000FF10\n    1010101010\n    101010FF10\n    000000FF14\n    0000FF00FF\n    00001F1017\n    0000FC04F4\n    1414171017\n    1414F404F4\n    0000FF00F7\n    1414141414\n    1414F700F7\n    1414141714\n    10101F101F\n    141414F414\n    1010F010F0\n    00001F101F\n    0000001F14\n    000000FC14\n    0000F010F0\n    1010FF10FF\n    141414FF14\n    1010101F00\n    000000F010\n    FFFFFFFFFF\n    F0F0F0F0F0\n    FFFFFF0000\n    000000FFFF\n    0F0F0F0F0F\n    3844443844\n    7C2A2A3E14\n    7E02020606\n    027E027E02\n    6355494163\n    3844443C04\n    407E201E20\n    06027E0202\n    99A5E7A599\n    1C2A492A1C\n    4C7201724C\n    304A4D4D30\n    3048784830\n    BC625A463D\n    3E49494900\n    7E0101017E\n    2A2A2A2A2A\n    44445F4444\n    40514A4440\n    40444A5140\n    0000FF0103\n    E080FF0000\n    08086B6B08\n    3612362436\n    060F090F06\n    0000181800\n    0000101000\n    3040FF0101\n    001F01011E\n    00191D1712\n    003C3C3C3C\n    0000000000`\n        loadStarted = false\n        loadPercent = 0\n        clear()\n    }\n\n\n    // Clear the OLED screen\n    /**\n     * Clears everything displayed on the OLED screen, leaving it blank and ready for new content.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_clear_screen\"\n    //% group=\"OLED\"\n    //% block=\"clear OLED display\"\n    //% weight=130 blockGap=8\n    export function clear() {\n        loadStarted = false\n        loadPercent = 0\n        command(SSD1306_SETCOLUMNADRESS)\n        command(0x00)\n        command(displayWidth - 1)\n        command(SSD1306_SETPAGEADRESS)\n        command(0x00)\n        command(displayHeight - 1)\n        let data = pins.createBuffer(17);\n        data[0] = 0x40; // Data Mode\n        for (let i = 1; i < 17; i++) {\n            data[i] = 0x00\n        }\n        // send display buffer in 16 byte chunks\n        for (let i = 0; i < screenSize; i += 16) {\n            pins.i2cWriteBuffer(chipAdress, data, false)\n        }\n        charX = xOffset\n        charY = yOffset\n    }\n\n\n    // Show string at x and y coordinates\n    /**\n     * Displays a string at the specified x and y coordinates on the OLED display.\n     * If the string exceeds the width of the screen, it will continue on the next line.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_write_string\"\n    //% group=\"OLED\"\n    //% block=\"show string at x: $x y: $y with text $str\"\n    //% x.defl=0\n    //% y.defl=0\n    //% weight=120 blockGap=8\n    export function writeStringAt(x: number, y: number, str: string) {\n        let originalX = charX;\n        let originalY = charY;\n        charX = x;\n        charY = y;\n\n        for (let i = 0; i < str.length; i++) {\n            if (charX > displayWidth - 6) {\n                newLine();\n            }\n            drawChar(charX, charY, str.charAt(i));\n            charX += 6;\n        }\n\n        // Reset the cursor back to the original position\n        charX = originalX;\n        charY = originalY;\n    }\n\n    // Show number at x and y coordinates\n    /**\n     * Displays a number at the specified x and y coordinates on the OLED display.\n     * The number is converted to a string before being displayed.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_write_number\"\n    //% group=\"OLED\"\n    //% block=\"show number $n at x: $x y: $y\"\n    //% weight=110 blockGap=8\n    export function writeNumAt(x: number, y: number, n: number) {\n        let numString = n.toString();  // Convert the number to a string\n        let charX = x;  // Starting X coordinate\n        let charY = y;  // Starting Y coordinate\n\n        // Loop through each character of the number string and display it at the coordinates\n        for (let i = 0; i < numString.length; i++) {\n            if (charX > displayWidth - 6) {\n                newLine();\n            }\n            drawChar(charX, charY, numString.charAt(i));\n            charX += 6;  // Move to the next character position\n        }\n    }\n\n    function newLine() {\n        charY++\n        charX = xOffset\n    }\n    function drawChar(x: number, y: number, c: string) {\n        command(SSD1306_SETCOLUMNADRESS)\n        command(x)\n        command(x + 5)\n        command(SSD1306_SETPAGEADRESS)\n        command(y)\n        command(y + 1)\n        let line = pins.createBuffer(2)\n        line[0] = 0x40\n        for (let i = 0; i < 6; i++) {\n            if (i === 5) {\n                line[1] = 0x00\n            } else {\n                let charIndex = c.charCodeAt(0)\n                let charNumber = font.getNumber(NumberFormat.UInt8BE, 5 * charIndex + i)\n                line[1] = charNumber\n\n            }\n            pins.i2cWriteBuffer(chipAdress, line, false)\n        }\n\n    }\n    function drawShape(pixels: Array<Array<number>>) {\n        let x1 = displayWidth\n        let y1 = displayHeight * 8\n        let x2 = 0\n        let y2 = 0\n        for (let i = 0; i < pixels.length; i++) {\n            if (pixels[i][0] < x1) {\n                x1 = pixels[i][0]\n            }\n            if (pixels[i][0] > x2) {\n                x2 = pixels[i][0]\n            }\n            if (pixels[i][1] < y1) {\n                y1 = pixels[i][1]\n            }\n            if (pixels[i][1] > y2) {\n                y2 = pixels[i][1]\n            }\n        }\n        let page1 = Math.floor(y1 / 8)\n        let page2 = Math.floor(y2 / 8)\n        let line = pins.createBuffer(2)\n        line[0] = 0x40\n        for (let x = x1; x <= x2; x++) {\n            for (let page = page1; page <= page2; page++) {\n                line[1] = 0x00\n                for (let i = 0; i < pixels.length; i++) {\n                    if (pixels[i][0] === x) {\n                        if (Math.floor(pixels[i][1] / 8) === page) {\n                            line[1] |= Math.pow(2, (pixels[i][1] % 8))\n                        }\n                    }\n                }\n                if (line[1] !== 0x00) {\n                    command(SSD1306_SETCOLUMNADRESS)\n                    command(x)\n                    command(x + 1)\n                    command(SSD1306_SETPAGEADRESS)\n                    command(page)\n                    command(page + 1)\n                    //line[1] |= pins.i2cReadBuffer(chipAdress, 2)[1]\n                    pins.i2cWriteBuffer(chipAdress, line, false)\n                }\n            }\n        }\n    }\n\n\n    // Draw a line from (x0, y0) to (x1, y1)\n    /**\n     * Draws a line between the two specified points on the OLED screen.\n     * The line is drawn using Bresenham's line algorithm.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_draw_line\"\n    //% group=\"OLED\"\n    //% block=\"draw line from:|x: $x0 y: $y0 to| x: $x1 y: $y1\"\n    //% x0.defl=0\n    //% y0.defl=0\n    //% x1.defl=20\n    //% y1.defl=20\n    //% weight=100 blockGap=8\n    export function drawLine(x0: number, y0: number, x1: number, y1: number) {\n        let pixels: Array<Array<number>> = []\n        let kx: number, ky: number, c: number, i: number, xx: number, yy: number, dx: number, dy: number;\n        let targetX = x1\n        let targetY = y1\n        x1 -= x0; kx = 0; if (x1 > 0) kx = +1; if (x1 < 0) { kx = -1; x1 = -x1; } x1++;\n        y1 -= y0; ky = 0; if (y1 > 0) ky = +1; if (y1 < 0) { ky = -1; y1 = -y1; } y1++;\n        if (x1 >= y1) {\n            c = x1\n            for (i = 0; i < x1; i++, x0 += kx) {\n                pixels.push([x0, y0])\n                c -= y1; if (c <= 0) { if (i != x1 - 1) pixels.push([x0 + kx, y0]); c += x1; y0 += ky; if (i != x1 - 1) pixels.push([x0, y0]); }\n                if (pixels.length > 20) {\n                    drawShape(pixels)\n                    pixels = []\n                    drawLine(x0, y0, targetX, targetY)\n                    return\n                }\n            }\n        } else {\n            c = y1\n            for (i = 0; i < y1; i++, y0 += ky) {\n                pixels.push([x0, y0])\n                c -= x1; if (c <= 0) { if (i != y1 - 1) pixels.push([x0, y0 + ky]); c += y1; x0 += kx; if (i != y1 - 1) pixels.push([x0, y0]); }\n                if (pixels.length > 20) {\n                    drawShape(pixels)\n                    pixels = []\n                    drawLine(x0, y0, targetX, targetY)\n                    return\n                }\n            }\n        }\n        drawShape(pixels)\n    }\n\n    /**\n     * Draws a rectangle on the OLED display from the starting point (x0, y0) to the end point (x1, y1).\n     * The rectangle is drawn by drawing four lines: top, bottom, left, and right.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_draw_rectangle\"\n    //% group=\"OLED\"\n    //% block=\"draw rectangle from:|x: $x0 y: $y0 to| x: $x1 y: $y1\"\n    //% x0.defl=0\n    //% y0.defl=0\n    //% x1.defl=20\n    //% y1.defl=20\n    //% weight=90 blockGap=8\n    export function drawRectangle(x0: number, y0: number, x1: number, y1: number) {\n        drawLine(x0, y0, x1, y0)\n        drawLine(x0, y1, x1, y1)\n        drawLine(x0, y0, x0, y1)\n        drawLine(x1, y0, x1, y1)\n    }\n\n\n    // Draw a circle at (x, y) with radius r\n    /**\n     * Draws a circle at the specified coordinates (x, y) with the given radius.\n     * The circle is drawn by plotting points along the circumference.\n     */\n    //% subcategory=\"Actuators\"\n    //% blockId=\"one_bit_prime_draw_circle\"\n    //% group=\"OLED\"\n    //% block=\"draw circle at x: $x y: $y radius: $r\"\n    //% x.defl=64\n    //% y.defl=32\n    //% r.defl=10\n    //% weight=80 blockGap=8\n    export function drawCircle(x: number, y: number, r: number) {\n        let theta = 0;\n        let step = Math.PI / 90;  // Adjust step for smoothness\n        let pixels: Array<Array<number>> = [];\n\n        while (theta < 2 * Math.PI) {\n            let xPos = Math.floor(x + r * Math.cos(theta));\n            let yPos = Math.floor(y + r * Math.sin(theta));\n            pixels.push([xPos, yPos]);\n            theta += step;\n        }\n\n        drawShape(pixels);\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n\n\n    ////////////////////\n    //  Rainbow BLOCKS  //\n    ////////////////////\n\n    let rainbowBuffer: Buffer = null; // LED data buffer\n    let rainbowNumLeds: number = 24;  // Number of LEDs\n    let rainbowBrightness: number = 255; // Default brightness\n\n\n    /**\n     * Initialize the Rainbow strip\n     * @param numLeds number of LEDs in the strip\n     */\n\n    //% blockId=\"rainbow_initialize\"\n    //% subcategory=\"Rainbow\"\n    //% block=\"initialize Rainbow with %numLeds|LEDs\"\n    //% weight=145 blockGap=8\n    export function initializeRainbow(numLeds: number): void {\n        rainbowNumLeds = numLeds;\n        rainbowBuffer = control.createBuffer(numLeds * 3);\n        clearRainbow(); // Ensure all LEDs start off\n    }\n\n\n\n    /**\n     * Show data on the Rainbow LEDs connected to P2\n    */\n    function showRainbowBuffer(): void {\n        if (rainbowBuffer) {\n            light.sendWS2812Buffer(rainbowBuffer, DigitalPin.P2); // Using P2 for Rainbow connection\n        }\n    }\n\n\n    /**\n     * Show rainbow colors on the strip\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_show_rainbow\"\n    //% block=\"show Rainbow\"\n    //% weight=140 blockGap=8\n    export function showRainbow(): void {\n        if (rainbowBuffer) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                let angle = (i / rainbowNumLeds) * 2 * Math.PI;\n                let red = Math.max(0, Math.sin(angle + (1 / 3) * Math.PI) * 127 + 128);\n                let green = Math.max(0, Math.sin(angle + (2 / 3) * Math.PI) * 127 + 128);\n                let blue = Math.max(0, Math.sin(angle + (4 / 3) * Math.PI) * 127 + 128);\n                setRainbowLedColorRaw(i, Math.floor(red), Math.floor(green), Math.floor(blue));\n            }\n            showRainbowBuffer();\n        }\n    }\n\n    /**\n     * Clear all LEDs on the strip\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_clear\"\n    //% block=\"clear Rainbow\"\n    //% weight=130 blockGap=8\n    export function clearRainbow(): void {\n        if (rainbowBuffer) {\n            rainbowBuffer.fill(0);\n            showRainbowBuffer();\n        }\n    }\n\n    /**\n     * Set color of all LEDs on the strip\n     * @param color the color to set\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#ff0000'\n    //% blockId=\"rainbow_set_color\"\n    //% block=\"set Rainbow color to %color\"\n    //% weight=120 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setRainbowColor(color: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            setRainbowLedColorRaw(i, red, green, blue);\n        }\n        showRainbowBuffer();\n    }\n\n    /**\n     * Set color of a specific LED on the strip\n     * @param ledIndex the index of the LED to change\n     * @param color the color to set\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#ff0000'\n    //% blockId=\"rainbow_set_led_color\"\n    //% block=\"set Rainbow LED %ledIndex|color to %color\"\n    //% weight=110 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function setRainbowLedColor(ledIndex: number, color: number): void {\n        if (rainbowBuffer && ledIndex < rainbowNumLeds) {\n            let red = (color >> 16) & 0xFF;\n            let green = (color >> 8) & 0xFF;\n            let blue = color & 0xFF;\n\n            let index = ledIndex * 3; // Calculate position in buffer\n            rainbowBuffer.setUint8(index, (red * rainbowBrightness) >> 8); // Scale brightness\n            rainbowBuffer.setUint8(index + 1, (green * rainbowBrightness) >> 8); // Scale brightness\n            rainbowBuffer.setUint8(index + 2, (blue * rainbowBrightness) >> 8); // Scale brightness\n\n            showRainbowBuffer(); // Send updated buffer to the LEDs\n        }\n    }\n\n    /**\n     * Set brightness of the strip\n     * @param brightness brightness level (0-255)\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_set_brightness\"\n    //% block=\"set Rainbow brightness to %brightness\"\n    //% weight=100 blockGap=8\n    export function setRainbowBrightness(brightness: number): void {\n        rainbowBrightness = Math.clamp(0, 255, brightness);\n        applyRainbowBrightness(); // Apply brightness scaling to the buffer\n        showRainbowBuffer(); // Update LEDs with adjusted brightness\n    }\n\n    /**\n     * Apply brightness scaling to the buffer\n     */\n    function applyRainbowBrightness(): void {\n        if (!rainbowBuffer) return;\n\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            let index = i * 3;\n            rainbowBuffer[index] = (rainbowBuffer[index] * rainbowBrightness) >> 8; // Scale Green\n            rainbowBuffer[index + 1] = (rainbowBuffer[index + 1] * rainbowBrightness) >> 8; // Scale Red\n            rainbowBuffer[index + 2] = (rainbowBuffer[index + 2] * rainbowBrightness) >> 8; // Scale Blue\n        }\n    }\n\n    /**\n     * Set color of a specific LED using raw RGB values\n     * @param ledIndex the index of the LED to change\n     * @param red Red value (0-255)\n     * @param green Green value (0-255)\n     * @param blue Blue value (0-255)\n     */\n    function setRainbowLedColorRaw(index: number, red: number, green: number, blue: number): void {\n        if (!rainbowBuffer || index >= rainbowNumLeds) return;\n\n        let brightnessScale = rainbowBrightness / 255; // Scale factor for brightness\n        rainbowBuffer[index * 3 + 0] = Math.floor(green * brightnessScale); // GRB: Green\n        rainbowBuffer[index * 3 + 1] = Math.floor(red * brightnessScale);   // GRB: Red\n        rainbowBuffer[index * 3 + 2] = Math.floor(blue * brightnessScale);  // GRB: Blue\n    }\n\n    /**\n     * Show a gradient pattern on the strip\n     * @param startHue the starting hue value (0-360)\n     * @param length the length of the gradient in number of LEDs\n     * @param fromColor starting color of the gradient\n     * @param toColor ending color of the gradient\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#ff0000' \n    //% blockId=\"rainbow_gradient\"\n    //% block=\"show gradient with start hue %startHue|length %length|from %fromColor|to %toColor\"\n    //% weight=90 blockGap=8\n    //% fromColor.shadow=\"brightColorNumberPicker\" \n    //% toColor.shadow=\"brightColorNumberPicker\"\n    export function showRainbowGradient(startHue: number, length: number, fromColor: number, toColor: number): void {\n        for (let i = 0; i < length; i++) {\n            let blendColor = blendColors(fromColor, toColor, i / length);\n            setRainbowLedColor(i, blendColor); // Custom function to set LED color\n        }\n        showRainbowBuffer(); // Custom function to apply changes\n    }\n\n    /**\n     * Helper function to blend two colors\n     * @param color1 the first color\n     * @param color2 the second color\n     * @param blend the blend factor between the two colors (0-1)\n     */\n    function blendColors(color1: number, color2: number, blend: number): number {\n        let r1 = (color1 >> 16) & 0xFF;\n        let g1 = (color1 >> 8) & 0xFF;\n        let b1 = color1 & 0xFF;\n\n        let r2 = (color2 >> 16) & 0xFF;\n        let g2 = (color2 >> 8) & 0xFF;\n        let b2 = color2 & 0xFF;\n\n        let r = Math.round(r1 * (1 - blend) + r2 * blend);\n        let g = Math.round(g1 * (1 - blend) + g2 * blend);\n        let b = Math.round(b1 * (1 - blend) + b2 * blend);\n\n        return (r << 16) | (g << 8) | b;\n    }\n\n\n    /**\n     * Custom color picker with all specified colors\n     */\n    //% subcategory=\"Rainbow\"\n    //% value.defl='#CCFF00'\n    //% weight=80 blockGap=15\n    //% blockId=brightColorNumberPicker block=\"%value\"\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.colours='[\"#CCFF00\",\"#CCCC00\",\"#CC9900\",\"#CC6600\",\"#CC3300\",\"#CC0000\",\"#660000\",\"#663300\",\"#666600\",\"#669900\",\"#66CC00\",\"#66FF00\",\"#00FF00\",\"#00CC00\",\"#009900\",\"#006600\",\"#003300\",\"#000000\",\"#CCFF33\",\"#CCCC33\",\"#CC9933\",\"#CC6633\",\"#CC3333\",\"#CC0033\",\"#660033\",\"#663333\",\"#666633\",\"#669933\",\"#66CC33\",\"#66FF33\",\"#00FF33\",\"#00CC33\",\"#009933\",\"#006633\",\"#003333\",\"#000033\",\"#CCFF66\",\"#CCCC66\",\"#CC9966\",\"#CC6666\",\"#CC3366\",\"#CC0066\",\"#660066\",\"#663366\",\"#666666\",\"#669966\",\"#66CC66\",\"#66FF66\",\"#00FF66\",\"#00CC66\",\"#009966\",\"#006666\",\"#003366\",\"#000066\",\"#CCFF99\",\"#CCCC99\",\"#CC9999\",\"#CC6699\",\"#CC3399\",\"#CC0099\",\"#660099\",\"#663399\",\"#666699\",\"#669999\",\"#66CC99\",\"#66FF99\",\"#00FF99\",\"#00CC99\",\"#009999\",\"#006699\",\"#003399\",\"#000099\",\"#CCFFCC\",\"#CCCCCC\",\"#CC99CC\",\"#CC66CC\",\"#CC33CC\",\"#CC00CC\",\"#6600CC\",\"#6633CC\",\"#6666CC\",\"#6699CC\",\"#66CCCC\",\"#66FFCC\",\"#00FFCC\",\"#00CCCC\",\"#0099CC\",\"#0066CC\",\"#0033CC\",\"#0000CC\",\"#CCFFFF\",\"#CCCCFF\",\"#CC99FF\",\"#CC66FF\",\"#CC33FF\",\"#CC00FF\",\"#6600FF\",\"#6633FF\",\"#6666FF\",\"#6699FF\",\"#66CCFF\",\"#66FFFF\",\"#00FFFF\",\"#00CCFF\",\"#0099FF\",\"#0066FF\",\"#0033FF\",\"#0000FF\",\"#FFFFFF\",\"#FFCCFF\",\"#FF99FF\",\"#FF66FF\",\"#FF33FF\",\"#FF00FF\",\"#9900FF\",\"#9933FF\",\"#9966FF\",\"#9999FF\",\"#99CCFF\",\"#99FFFF\",\"#33FFFF\",\"#33CCFF\",\"#3399FF\",\"#3366FF\",\"#3333FF\",\"#3300FF\",\"#FFFFCC\",\"#FFCCCC\",\"#FF99CC\",\"#FF66CC\",\"#FF33CC\",\"#FF00CC\",\"#9900CC\",\"#9933CC\",\"#9966CC\",\"#9999CC\",\"#99CCCC\",\"#99FFCC\",\"#33FFCC\",\"#33CCCC\",\"#3399CC\",\"#3366CC\",\"#3333CC\",\"#3300CC\",\"#FFFF99\",\"#FFCC99\",\"#FF9999\",\"#FF6699\",\"#FF3399\",\"#FF0099\",\"#990099\",\"#993399\",\"#996699\",\"#999999\",\"#99CC99\",\"#99FF99\",\"#33FF99\",\"#33CC99\",\"#339999\",\"#336699\",\"#333399\",\"#330099\",\"#FFFF66\",\"#FFCC66\",\"#FF9966\",\"#FF6666\",\"#FF3366\",\"#FF0066\",\"#990066\",\"#993366\",\"#996666\",\"#999966\",\"#99CC66\",\"#99FF66\",\"#33FF66\",\"#33CC66\",\"#339966\",\"#336666\",\"#333366\",\"#330066\",\"#FFFF33\",\"#FFCC33\",\"#FF9933\",\"#FF6633\",\"#FF3333\",\"#FF0033\",\"#990033\",\"#993333\",\"#996633\",\"#999933\",\"#99CC33\",\"#99FF33\",\"#33FF33\",\"#33CC33\",\"#339933\",\"#336633\",\"#333333\",\"#330033\"]'\n    //% value.fieldOptions.columns=18 value.fieldOptions.className='rgbColorPicker'\n    export function rainbowColorPicker(value: number): number {\n        return value;\n    }\n\n    /**\n     * Get a random color\n     */\n    //% blockId=\"rainbow_random_color\"\n    //% value.defl='#ff0000' \n    //% weight=70 blockGap=15\n    //% block=\"random color\"\n    //% subcategory=\"Rainbow\"\n    export function rainbowRandomColor(): number {\n        return Math.randomRange(0, 0xFFFFFF);\n    }\n\n    /**\n     * Convert RGB values to a color number\n     * @param r Red value (0-255)\n     * @param g Green value (0-255)\n     * @param b Blue value (0-255)\n     */\n    //% blockId=\"rainbow_rgb_to_color\"\n    //% value.defl='#ff0000' \n    //% weight=60 blockGap=15\n    //% block=\"R %r|G %g|B %b\"\n    //% r.min=0 r.max=255\n    //% g.min=0 g.max=255\n    //% b.min=0 b.max=255\n    //% subcategory=\"Rainbow\"\n    export function rainbowRgbToColor(r: number, g: number, b: number): number {\n        return (r << 16) | (g << 8) | b;\n    }\n\n    /**\n     * Convert HSL values to a color number\n     * @param h Hue (0-360)\n     * @param s Saturation (0-100)\n     * @param l Luminosity (0-100)\n     */\n    //% blockId=\"rainbow_hsl_to_color\"\n    //% value.defl='#ff0000' \n    //% weight=50 blockGap=15\n    //% subcategory=\"Rainbow\"\n    //% block=\"hue %h|saturation %s|luminosity %l\"\n    //% h.min=0 h.max=360\n    //% s.min=0 s.max=100\n    //% l.min=0 l.max=100\n    export function rainbowHslToColor(h: number, s: number, l: number): number {\n        return rainbowHslToRgb(h, s, l); // Custom function for HSL to RGB\n    }\n\n    /**\n     * Convert HSL values to RGB\n     * @param h Hue (0-360)\n     * @param s Saturation (0-100)\n     * @param l Luminosity (0-100)\n     * @returns A packed RGB number (24-bit)\n     */\n    function rainbowHslToRgb(h: number, s: number, l: number): number {\n        h = h % 360; // Ensure hue wraps around 360\n        s = s / 100; // Convert saturation to a decimal\n        l = l / 100; // Convert luminosity to a decimal\n\n        const c = (1 - Math.abs(2 * l - 1)) * s; // Chroma\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1)); // Second largest component\n        const m = l - c / 2;\n\n        let r = 0, g = 0, b = 0;\n\n        if (h >= 0 && h < 60) {\n            r = c; g = x; b = 0;\n        } else if (h >= 60 && h < 120) {\n            r = x; g = c; b = 0;\n        } else if (h >= 120 && h < 180) {\n            r = 0; g = c; b = x;\n        } else if (h >= 180 && h < 240) {\n            r = 0; g = x; b = c;\n        } else if (h >= 240 && h < 300) {\n            r = x; g = 0; b = c;\n        } else if (h >= 300 && h < 360) {\n            r = c; g = 0; b = x;\n        }\n\n        // Convert RGB components to 8-bit values and pack into a single integer\n        const red = Math.round((r + m) * 255);\n        const green = Math.round((g + m) * 255);\n        const blue = Math.round((b + m) * 255);\n\n        return (red << 16) | (green << 8) | blue;\n    }\n\n    /**\n     * Custom function to set a specific LED's color on the rainbow LED strip\n     * @param index LED index\n     * @param color RGB color\n     */\n    function rainbowSetLedColor(index: number, color: number): void {\n        // Send the appropriate signal to the LEDs\n        let r = (color >> 16) & 0xFF;\n        let g = (color >> 8) & 0xFF;\n        let b = color & 0xFF;\n\n        // Logic to send r, g, and b to the specific LED\n        rainbowSendSignalToLed(index, r, g, b);\n    }\n\n    /**\n     * Function to send RGB signal to a specific LED in the rainbow strip\n     */\n    function rainbowSendSignalToLed(index: number, r: number, g: number, b: number): void {\n        // Use custom bit-banging logic or timing logic here\n    }\n\n    /**\n     * Function to apply updates to the rainbow LEDs\n     */\n    function rainbowUpdateLeds(): void {\n        // Trigger any necessary latch or update commands for the LEDs\n    }\n\n    /**\n     * Breathing effect on the Rainbow strip.\n     * The LED brightness will gradually increase and decrease, creating a \"breathing\" effect.\n     * @param duration The total duration for the breathing cycle in seconds.\n     * @param color The color for the breathing effect.\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_breathing_effect\"\n    //% block=\"start breathing effect for %duration|seconds with color %color\"\n    //% group=Effects weight=85 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    //% duration.defl=5\n    export function rainbowBreathingEffect(duration: number, color: number): void {\n        let cycleTime = (duration * 1000) / 2; // Convert seconds to milliseconds and split into fade-in and fade-out\n        let steps = 255; // Number of steps for fading (brightness from 0 to 255)\n        let stepTime = cycleTime / steps; // Time per step in milliseconds\n\n        // Gradually increase brightness (fade-in)\n        for (let brightness = 0; brightness <= 255; brightness++) {\n            setRainbowBrightness(brightness); // Set brightness\n            applyRainbowColor(color);        // Apply the selected color\n            basic.pause(stepTime);\n        }\n\n        // Gradually decrease brightness (fade-out)\n        for (let brightness = 255; brightness >= 0; brightness--) {\n            setRainbowBrightness(brightness); // Set brightness\n            applyRainbowColor(color);        // Apply the selected color\n            basic.pause(stepTime);\n        }\n    }\n\n    /**\n     * Apply the selected color to the Rainbow LED strip\n     * @param color The color to set\n     */\n    function applyRainbowColor(color: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            setRainbowLedColorRaw(i, red, green, blue);\n        }\n        showRainbowBuffer(); // Refresh the LEDs\n    }\n\n\n    /**\n     * Color Wipe effect on the Rainbow strip.\n     * LEDs light up one by one in a selected color.\n     * @param color the color to wipe\n     * @param delay time between each LED lighting in ms\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_color_wipe\"\n    //% block=\"color wipe with %color|delay %delay s\"\n    //% group=Effects weight=80 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowColorWipe(color: number, delay: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            setRainbowLedColorRaw(i, red, green, blue);\n            showRainbowBuffer();\n            basic.pause(delay * 1000);\n        }\n    }\n\n    /**\n     * Rainbow cycle effect on the Rainbow strip.\n     * Displays a smooth rainbow transition across all LEDs.\n     * @param duration total duration of the rainbow cycle in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_rainbow_cycle\"\n    //% block=\"rainbow cycle for %duration s\"\n    //% group=Effects weight=75 blockGap=8\n    export function rainbowCycle(duration: number): void {\n        let steps = 255; // Number of color steps\n        let stepTime = (duration * 1000) / steps; // Time per step in ms\n\n        for (let j = 0; j < steps; j++) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                let color = wheel((i * 256 / rainbowNumLeds + j) & 255);\n                let red = (color >> 16) & 0xFF;\n                let green = (color >> 8) & 0xFF;\n                let blue = color & 0xFF;\n                setRainbowLedColorRaw(i, red, green, blue);\n            }\n            showRainbowBuffer();\n            basic.pause(stepTime);\n        }\n    }\n\n    /**\n     * Helper function to generate a color from the wheel position\n     * @param position wheel position (0-255)\n     */\n    function wheel(position: number): number {\n        if (position < 85) {\n            return (position * 3 << 16) | ((255 - position * 3) << 8);\n        } else if (position < 170) {\n            position -= 85;\n            return ((255 - position * 3) << 16) | (position * 3);\n        } else {\n            position -= 170;\n            return (position * 3 << 8) | (255 - position * 3);\n        }\n    }\n\n    /**\n     * Twinkle effect on the Rainbow strip.\n     * Random LEDs light up briefly.\n     * @param color the color of the twinkle\n     * @param duration total duration of the twinkle effect in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_twinkle_effect\"\n    //% block=\"twinkle with %color|for %duration s\"\n    //% group=Effects weight=70 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowTwinkle(color: number, duration: number): void {\n        let endTime = input.runningTime() + duration * 1000;\n        while (input.runningTime() < endTime) {\n            let index = Math.randomRange(0, rainbowNumLeds - 1);\n            let red = (color >> 16) & 0xFF;\n            let green = (color >> 8) & 0xFF;\n            let blue = color & 0xFF;\n\n            setRainbowLedColorRaw(index, red, green, blue);\n            showRainbowBuffer();\n            basic.pause(100);\n\n            setRainbowLedColorRaw(index, 0, 0, 0); // Turn off the LED\n            showRainbowBuffer();\n            basic.pause(100);\n        }\n    }\n\n\n    /**\n     * Theater Chase effect on the Rainbow strip.\n     * A pattern of moving dots in a specific color.\n     * @param color the color of the chase\n     * @param duration total duration of the chase effect in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_theater_chase\"\n    //% block=\"theater chase with color %color|for %duration|s\"\n    //% group=Effects weight=65 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowTheaterChase(color: number, duration: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n\n        let endTime = input.runningTime() + duration * 1000; // Duration in milliseconds\n\n        while (input.runningTime() < endTime) {\n            for (let q = 0; q < 3; q++) {\n                // Light up every 3rd LED starting at position q\n                for (let i = 0; i < rainbowNumLeds; i += 3) {\n                    let index = i + q;\n                    if (index < rainbowNumLeds) {\n                        setRainbowLedColorRaw(index, red, green, blue);\n                    }\n                }\n                showRainbowBuffer();\n                basic.pause(50);\n\n                // Turn off the same LEDs\n                for (let i = 0; i < rainbowNumLeds; i += 3) {\n                    let index = i + q;\n                    if (index < rainbowNumLeds) {\n                        setRainbowLedColorRaw(index, 0, 0, 0); // Turn off the LED\n                    }\n                }\n                showRainbowBuffer();\n                basic.pause(50);\n            }\n        }\n\n        // Clear all LEDs after the duration ends\n        clearRainbow();\n    }\n\n    /**\n     * Wave effect on the Rainbow strip.\n     * Brightness varies across the strip in a sine wave pattern.\n     * @param color the base color of the wave\n     * @param duration total duration of the wave effect in seconds\n     */\n    //% subcategory=\"Rainbow\"\n    //% blockId=\"rainbow_wave_effect\"\n    //% block=\"wave effect with %color|for %duration s\"\n    //% group=Effects weight=60 blockGap=8\n    //% color.shadow=\"brightColorNumberPicker\"\n    export function rainbowWave(color: number, duration: number): void {\n        let red = (color >> 16) & 0xFF;\n        let green = (color >> 8) & 0xFF;\n        let blue = color & 0xFF;\n\n        let steps = 255;\n        let stepTime = (duration * 1000) / steps;\n\n        for (let j = 0; j < steps; j++) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                let brightness = (Math.sin((i + j) * Math.PI / 180) + 1) * 127.5; // Sine wave\n                setRainbowLedColorRaw(i, (red * brightness) / 255, (green * brightness) / 255, (blue * brightness) / 255);\n            }\n            showRainbowBuffer();\n            basic.pause(stepTime);\n        }\n    }\n}\n","pxt.json":"{\n    \"name\": \"Onebit_APDS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"Onebit_APDS.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1735215374657}